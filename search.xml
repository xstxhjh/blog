<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Grid 实现的响应式布局]]></title>
    <url>%2F2019%2F02%2F15%2FGrid%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[Grid 实现的响应式布局© Chirenmeng 快速掌握 Grid 布局第一步：将容器元素定义为一个 grid(网格) 布局12345678&lt;div class="wrapper"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt;&lt;/div&gt; 123.wrapper &#123; display: grid;&#125; 第二步：为网格定义定义 columns(列) 和 rows(行)使用 grid-template-columns 和 grid-template-rows 设置列和行的尺寸大小。 1234567891011.wrapper &#123; display: grid; grid-template-columns: 300px 300px 300px; /* 网格划分为3列宽为300px */ grid-template-rows: 150px 150px 150px; /* 网格划分为2行高为150px */ /* 我们只在图片上看到 3×2 的网格，而我们定义的是 3×3 的网格。 这是因为我们只有 6 个子元素来填满这个网格。 如果我们再加 3 个子元素，那么最后一行也会被填满。 */&#125; 第三步：调整子元素的位置与大小通过 grid-column 和 grid-row 将其子元素放入网格中。 1234567.wrapper &gt; div:nth-child(1) &#123; grid-column-start: 1; grid-column-end: 4; /* 也可以将上面两行代码进行合并 */ grid-column: 1 / 4;&#125; 子元素将从第一条网格线开始，到第四条网格线结束。（网格线为下图黑色区域） 结合上面所学的知识你就可以完成简单的 Grid 布局啦！当然还有更多灵活、强大的功能，需要你去进一步学习。 使用等分(fr)单位实现基本的响应式等分单位是一个自适应单位，等分单位被用于在一系列长度值中分配剩余空间，如果多个已指定了多个部分，则剩下的空间根据各自的数字按比例分配。 12345678&lt;div class="container"&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt;&lt;/div&gt; 12345.container &#123; display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 150px 150px;&#125; 响应式网格布局repeat() 创建重复的网格轨道12345.container &#123; display: grid; grid-template-columns: repeat(3, 300px); grid-template-rows: repeat(2, 150px);&#125; auto-fit 自适应列的个数开发者只需要指定列宽，浏览器将会自适应得到有多少列 123456.container &#123; display: grid; grid-gap: 5px; grid-template-columns: repeat(auto-fit, 300px); grid-template-rows: repeat(2, 150px);&#125; minmax() 最大值与最小值minmax() 函数定义大于或等于 min 且小于或等于 max 的大小范围 123456.container &#123; display: grid; grid-gap: 5px; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); grid-template-rows: repeat(2, 150px);&#125; 结合上面所学的三种方法，我们就得到了如下的效果图。 CSS Grid 快速完成经典网站布局 第一步：搭建 HTML 结构 123456&lt;div class="container"&gt; &lt;div class="header"&gt;HEADER&lt;/div&gt; &lt;div class="menu"&gt;MENU&lt;/div&gt; &lt;div class="content"&gt;CONTENT&lt;/div&gt; &lt;div class="footer"&gt;FOOTER&lt;/div&gt;&lt;/div&gt; 第二步：设置为网格容器 12345678910111213141516171819202122232425262728293031.container &#123; display: grid; grid-template-columns: repeat(12, 1fr); /* 创建一个 12 列的网格 */ grid-template-rows: 100px 400px 100px; /* 创建 3 行，第一、三行高度是 100px ，第二行高度是 400px */ grid-gap: 5px; /* 网格项之间的间隙为5px */ /* 定义网格区域 通过获取网格项中的grid-area属性值（名称），来定义网格模版。 重复网格区（grid-area）名称将跨越网格单元格，‘.’代表空网格单元。 */ grid-template-areas: 'h h h h h h h h h h h h' 'm m c c c c c c c c c c' 'f f f f f f f f f f f f'; /* 给网格项设定网格区域名称 */ .header &#123; grid-area: h; &#125; .menu &#123; grid-area: m; &#125; .content &#123; grid-area: c; &#125; .footer &#123; grid-area: f; &#125;&#125; 第三步：添加响应式布局 12345678@media screen and (max-width: 640px) &#123; .container &#123; grid-template-areas: 'm m m m m m h h h h h h' 'c c c c c c c c c c c c' 'f f f f f f f f f f f f'; &#125;&#125; 原来我们总是通过 float、postion 等 hack 方式处理网页的布局，flexbox 很大程度改善了我们的布局方式，但是它是简单的一维布局，适合做局部布局。grid 布局，是一个二维基于网格的布局系统，用于整个页面的规划，它能解决更多复杂的页面布局，grid 与 flexbox 配合使用效果更佳。 Grid 实现的响应式布局 快速掌握 Grid 布局 第一步：将容器元素定义为一个 grid(网格) 布局 第二步：为网格定义定义 columns(列) 和 rows(行) 第三步：调整子元素的位置与大小 使用等分(fr)单位实现基本的响应式 响应式网格布局 repeat() 创建重复的网格轨道 auto-fit 自适应列的个数 minmax() 最大值与最小值 CSS Grid 快速完成经典网站布局]]></content>
      <categories>
        <category>响应式布局</category>
      </categories>
      <tags>
        <tag>响应式布局</tag>
        <tag>Grid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式 Web 设计]]></title>
    <url>%2F2019%2F01%2F19%2F%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[响应式 Web 设计© Chirenmeng 概念响应式 Web 设计是一个让用户通过各种尺寸的设备浏览网站获得良好的视觉效果的方法。 例如，您先在计算机显示器上浏览一个网站，然后在智能手机上浏览，智能手机的屏幕尺寸远小于计算机显示器，但是你却没有感觉到任何差别，两者的用户体验几乎一样，这说明这个网站在响应式设计方面做得很好。 方法设置 Meta 标签大多数移动浏览器将 HTML 页面放大为宽的视图以符合屏幕分辨率。你可以使用视图的 meta 标签来进行重置。下面的视图标签告诉浏览器，使用设备的宽度作为视图宽度并禁止初始的缩放。 123456789101112131415161718192021&lt;meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt;&lt;meta name="HandheldFriendly" content="true" /&gt;&lt;!-- width=device-width--宽度为设备宽度如果你的页面宽度小于设备宽度，就需要修改一下这个属性，不然的话会出现可以页面左右滑动initial-scale - 初始的缩放比例minimum-scale - 允许用户缩放到的最小比例 maximum-scale - 允许用户缩放到的最大比例 user-scalable - 用户是否可以手动缩放--&gt; 通过媒介查询来设置样式Media Queries 是响应式设计的核心，它根据条件告诉浏览器如何为指定视图宽度渲染页面。 @media 引入 123456789101112@media screen and (min-width: 1200px) &#123; /* 如果视窗宽度 &gt;= 1200px，將会加载此 CSS。 */&#125;@media screen and (min-width: 768px) and (max-width: 979px) &#123; /* 如果视窗宽度介于 768px ~ 979px，将会载入此 CSS。 */&#125;@media screen and (max-width: 767px) &#123; /* 如果视窗宽度 &lt;= 768px，将会载入此 CSS。 */&#125;@media screen and (max-device-width: 480px) &#123; /* 若视窗宽度 &lt;= 480px，则载入此CSS。 */&#125; link 方法引入 1&lt;link rel="stylesheet" media="screen and (max-width: 600px)" href="small.css" /&gt; 补充：media query 中的 not、only、all 等关键字 not: not 是用来排除掉某些特定的设备的，比如 @media not print（非打印设备） only: 用来定某种特别的媒体类型。对于支持 Media Queries 的移动设备来说，如果存在 only 关键字，移动设备的 Web 浏览器会忽略 only 关键字并直接根据后面的表达式应用样式文件。对于不支持 Media Queries 的设备但能够读取 Media Type 类型的 Web 浏览器，遇到 only 关键字时会忽略这个样式文件。 all: 所有设备，这个应该经常看到 字体设置一个响应式的字体应关联它的父容器的宽度，这样才能适应客户端屏幕。 1、确定基数：一般 10px，自己记住就行，不用写进代码里 2、html {font-size:百分数;} 百分数=基数/16 基数 10 百分数 62.5% 基数 14 百分数 87.5% 3、px 换算 rem 公式=想要的 px 值/基数 也就是说，当你设置 html {font-size:62.5%;}，你想给容器里的文字设置字号 14px，换算成 rem 就是 14px/10——1.4rem 这样子 如果使用 em 单位的时候，计算机就会自己去找你 body 设置的字体大小 body {font-size:14px;} 这样设置后，如果我想要一个 14px 的外边距，我就用 14px/14px——1em 这样啦。 12345678910111213141516171819html &#123; font-size: 100%;&#125;/* 完成后，你可以定义响应式字体： */@media (min-width: 640px) &#123; body &#123; font-size: 1rem; &#125;&#125;@media (min-width: 960px) &#123; body &#123; font-size: 1.2rem; &#125;&#125;@media (min-width: 1200px) &#123; body &#123; font-size: 1.5rem; &#125;&#125; 图片自适应1234567.img-responsive &#123; display: inline-block; height: auto; max-width: 100%;&#125;/* 可以让图像按比例缩放，不超过其父元素的尺寸。 */ 百分比一般的子元素的百分比完全相对于直接父元素，height 百分比相对于 height，width 百分比相对于 width。 以下是特殊的情况： 1、子元素的 top 和 bottom、left、right 如果设置百分比，则相对于直接非 static 定位(默认定位)的父元素的高度 2、padding 和 margin 都是只相对直接父元素的 width。 3、border- radius 是相对于自身的宽度。 导言: 通过媒体查询，可以通过给不同分辨率的设备编写不同的样式来实现响应式的布局。 但是媒体查询的缺点也很明显，需要改变的样式太多的话，那么多套样式代码会很繁琐。 响应式 Web 设计 概念 方法 设置 Meta 标签 通过媒介查询来设置样式 字体设置 图片自适应 百分比]]></content>
      <categories>
        <category>响应式布局</category>
      </categories>
      <tags>
        <tag>响应式布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序按需引入外部字体]]></title>
    <url>%2F2019%2F01%2F15%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8C%89%E9%9C%80%E5%BC%95%E5%85%A5%E5%A4%96%E9%83%A8%E5%AD%97%E4%BD%93%2F</url>
    <content type="text"><![CDATA[微信小程序 字体© Chirenmeng 按需添加外部字体转码网站（http://transfonter.org 上传的文件不能超过 5M） 微信不支持外部文件夹的权限所以不能直接引用 ttf 文件，我们可以将字体 ttf 文件转码为 base64 的格式，然后放在 app.wxss 里。 然后问题就来了，一个字体库常常有 3M 左右，当你发现你好不容易打开了转码后的 CSS 文件然后复制在微信小程序 app.wxss 里的时候，就会报错。 然后我就想用 fontweb 在线导入字体，试了一下可以用，但因为会进行一次网络请求，所以文字加载完成之后，才会出现（看网速快慢），体验效果特别不好（当然，你可以在首屏加载完成之后再跳转）。所以我选择老老实实的使用 base64 转码引入文件了。 如果你想导入一个字体库（3M 左右，比你的小程序还大），基本是不可能了。 但经过我漫长的实践，我们还是可以导入我们想要文字的字体样式的。 可能有点麻烦，如果你想简单点，直接用图片把，但图片不好的地方：难改，不能和 css 结合做动画效果，不易灵活复用。 正式开始： 首先下载 java 然后配置 java 环境 下载 ant 然后配置 ant 环境 下载 sfntly，找到 sfntly 里面的 sfnttool 目录（搜索一下 sfnttool 就好了） 然后你要确定你的 sfnttool 目录下有一个 sfnttool.jar 的文件(不知道为什么我的没有，所以我自己去网上下了一个) 然后在 sfnttool 目录里面 shift+右键进入 cmd 命令窗口（powershell 窗口也可以） 输入 java -jar sfnttool.jar -s ‘要进行提取的文字’ 提取前的文件名.ttf 提取后的文件名.ttf 然后将你提取后的文件进行 base64 转码在 .wxss 文件里引用就好了 这样你就可以在微信小程序里显示你想要的字体，或者是其它国家的语言了。 ！！现在微信小程序支持动态加载网络字体了 → → wx.loadFontFace(Object object)]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>字体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[30秒学习JavaScript代码段(Date篇)]]></title>
    <url>%2F2019%2F01%2F09%2F30-seconds-of-code-date%2F</url>
    <content type="text"><![CDATA[Date 篇© Chirenmeng 本文译自：30-seconds-of-code dayOfYear获取今天是今年的第几天。 使用 new date（）和 date.prototype.getfullyear（）将一年中的第一天作为日期对象，从提供的日期中减去该日期，然后除以每天的毫秒数得到结果。使用 math.floor（）将生成的日计数适当地四舍五入为整数。 12345const dayOfYear = date =&gt; Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24)// 示例 ↓dayOfYear(new Date()) // 9 formatDuration将时间戳转为可读日期。 将 ms 除以适当的值，得到日、小时、分钟、秒和毫秒的适当值。使用 object.entries（）和 array.prototype.filter（）只保留非零值。使用 array.prototype.map（）为每个值创建字符串，并适当地使用复数形式。使用 string.prototype.join（“，”）将值组合成字符串。 123456789101112131415161718const formatDuration = ms =&gt; &#123; if (ms &lt; 0) ms = -ms const time = &#123; day: Math.floor(ms / 86400000), hour: Math.floor(ms / 3600000) % 24, minute: Math.floor(ms / 60000) % 60, second: Math.floor(ms / 1000) % 60, millisecond: Math.floor(ms) % 1000 &#125; return Object.entries(time) .filter(val =&gt; val[1] !== 0) .map(([key, val]) =&gt; `$&#123;val&#125; $&#123;key&#125;$&#123;val !== 1 ? 's' : ''&#125;`) .join(', ')&#125;// 示例 ↓formatDuration(1001) // '1 second, 1 millisecond'formatDuration(34325055574) // '397 days, 6 hours, 44 minutes, 15 seconds, 574 milliseconds' getColonTimeFromDate从日期对象返回格式为 hh:mm:ss 的字符串。 使用 date.prototype.toTimeString（）和 string.prototype.slice（）获取给定日期对象的 hh:mm:ss 部分。 1234const getColonTimeFromDate = date =&gt; date.toTimeString().slice(0, 8)// 示例 ↓getColonTimeFromDate(new Date()) // "08:38:00" getDaysDiffBetweenDates返回两个日期之间的差值（以天为单位）。 12345const getDaysDiffBetweenDates = (dateInitial, dateFinal) =&gt; (dateFinal - dateInitial) / (1000 * 3600 * 24)// 示例 ↓getDaysDiffBetweenDates(new Date('2017-12-13'), new Date('2017-12-22')) // 9 getMeridiemSuffixOfInteger将整数转换为后缀字符串，并根据其值添加 AM 或 PM。 使用模运算符（%）和条件检查将整数转换为带 Meridiem 后缀的字符串化 12 小时格式。 1234567891011121314const getMeridiemSuffixOfInteger = num =&gt; num === 0 || num === 24 ? 12 + 'am' : num === 12 ? 12 + 'pm' : num &lt; 12 ? (num % 12) + 'am' : (num % 12) + 'pm'// 示例 ↓getMeridiemSuffixOfInteger(0) // "12am"getMeridiemSuffixOfInteger(11) // "11am"getMeridiemSuffixOfInteger(13) // "1pm"getMeridiemSuffixOfInteger(25) // "1pm" isAfterDate检查日期是否在其他日期之后。 使用大于运算符（&gt;）检查第一个日期是否在第二个日期之后。 1234const isAfterDate = (dateA, dateB) =&gt; dateA &gt; dateB// 示例 ↓isAfterDate(new Date(2010, 10, 21), new Date(2010, 10, 20)) // true isBeforeDate检查日期是否早于其他日期。 使用小于运算符（&lt;）检查第一个日期是否在第二个日期之前。 1234const isBeforeDate = (dateA, dateB) =&gt; dateA &lt; dateB// 示例 ↓isBeforeDate(new Date(2010, 10, 20), new Date(2010, 10, 21)) // true isSameDate检查日期是否与其他日期相同。 使用 date.prototype.toisString（）和严格的相等检查（==）检查第一个日期是否与第二个日期相同。 1234const isSameDate = (dateA, dateB) =&gt; dateA.toISOString() === dateB.toISOStri// 示例 ↓isSameDate(new Date(2010, 10, 20), new Date(2010, 10, 20)) // true maxDate返回给定日期的最大值。 使用 math.max.apply（）查找最大日期值，使用 new date（）将其转换为日期对象。 12345678910const maxDate = (...dates) =&gt; new Date(Math.max.apply(null, ...dates))// 示例 ↓const array = [ new Date(2017, 4, 13), new Date(2018, 2, 12), new Date(2016, 0, 10), new Date(2016, 0, 9)]maxDate(array) // 2018-03-11T22:00:00.000Z minDate返回给定日期的最小值。 使用 math.min.apply（）查找最小日期值，使用 new date（）将其转换为日期对象。 12345678910const minDate = (...dates) =&gt; new Date(Math.min.apply(null, ...dates))// 示例 ↓const array = [ new Date(2017, 4, 13), new Date(2018, 2, 12), new Date(2016, 0, 10), new Date(2016, 0, 9)]minDate(array) // 2016-01-08T22:00:00.000Z tomorrow生成明天日期的字符串表示形式。 使用 new date（）获取今天的日期，使用 date.getDate（）和 date.setDate（）添加一天，并将日期对象转换为字符串。 12345678910111213const tomorrow = (long = false) =&gt; &#123; let t = new Date() t.setDate(t.getDate() + 1) const ret = `$&#123;t.getFullYear()&#125;-$&#123;String(t.getMonth() + 1).padStart( 2, '0' )&#125;-$&#123;String(t.getDate()).padStart(2, '0')&#125;` return !long ? ret : `$&#123;ret&#125;T00:00:00`&#125;// 示例 ↓tomorrow() // 2017-12-27 (if current date is 2017-12-26)tomorrow(true) // 2017-12-27T00:00:00 (if current date is 2017-12-26) Date 篇 dayOfYear formatDuration getColonTimeFromDate getDaysDiffBetweenDates getMeridiemSuffixOfInteger isAfterDate isBeforeDate isSameDate maxDate minDate tomorrow]]></content>
      <categories>
        <category>30-seconds-of-code</category>
      </categories>
      <tags>
        <tag>Date</tag>
        <tag>ECMAScript6+</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[30秒学习JavaScript代码段(Array篇)]]></title>
    <url>%2F2019%2F01%2F07%2F30-seconds-of-code-array%2F</url>
    <content type="text"><![CDATA[Array 篇© Chirenmeng 本文译自：30-seconds-of-code all如果数组中的所有元素执行给定的函数都返回 true，则返回 true，否则返回 false。 使用 Array.prototype.very()遍历数组中的所有元素是否执行 fn 返回 true。如果省略第二个参数 fn，将使用 Boolean 函数作为默认值。 12345const all = (arr, fn = Boolean) =&gt; arr.every(fn)// 示例 ↓all([4, 2, 3], x =&gt; x &gt; 1) // trueall([1, 2, 3]) // true allEqual检查数组中的所有元素是否相等。 使用 Array.prototype.very()检查数组中的所有元素是否与第一个元素相同。 12345const allEqual = arr =&gt; arr.every(val =&gt; val === arr[0])// 示例 ↓allEqual([1, 2, 3, 4, 5, 6]) // falseallEqual([1, 1, 1, 1]) // true any如果数组中至少有一个元素执行给定的函数都返回 true，则返回 true，否则返回 false。 使用 Array.prototype.some()遍历集合中是否有元素调用 fn 返回 true。省略第二个参数 fn，将使用 Boolean 函数作为默认值。 12345const any = (arr, fn = Boolean) =&gt; arr.some(fn)// 示例 ↓any([0, 1, 2, 0], x =&gt; x &gt;= 2) // trueany([0, 0, 1, 0]) // true arrayToCSV将二维数组转换为逗号分隔值(CSV)字符串。 使用 Array.prototype.map()和 Array.prototype.join(delimiter)将单个一维数组(行)组合成字符串。使用 Array.prototype.join(“\n”)将所有行组合成一个 CSV 字符串，用换行符分隔每行。省略第二个参数 delimiter，将使用,作为默认分隔符。 123456const arrayToCSV = (arr, delimiter = ',') =&gt; arr.map(v =&gt; v.map(x =&gt; `"$&#123;x&#125;"`).join(delimiter)).join('\n')// 示例 ↓arrayToCSV([['a', 'b'], ['c', 'd']]) // '"a","b"\n"c","d"'arrayToCSV([['a', 'b'], ['c', 'd']], ';') // '"a";"b"\n"c";"d"' bifurcate将值分成两组。如果 filter 中的元素是真的，则数组中的相应元素属于第一组；否则，它属于第二组。 使用 Array.prototype.reduce()和 Array.prototype.push()根据 filter 将元素添加到组中。 123456const bifurcate = (arr, filter) =&gt; arr.reduce((acc, val, i) =&gt; (acc[filter[i] ? 0 : 1].push(val), acc), [[], []])// 示例 ↓bifurcate(['beep', 'boop', 'foo', 'bar'], [true, true, false, true])// [ ['beep', 'boop', 'bar'], ['foo'] ] array.reduce(function(accumulator, currentValue, currentIndex, array), initialValue)； accumulator：上一次调用回调返回的值，或者是提供的初始值（initialValue） currentValue：数组中正在处理的元素 currentIndex：数据中正在处理的元素索引，如果提供了 initialValue ，从 0 开始；否则从 1 开始 array： 调用 reduce 的数组 initialValue：可选项，其值用于第一次调用 callback 的第一个参数。如果没有设置初始值，则将数组中的第一个元素作为初始值。空数组调用 reduce 时没有设置初始值将会报错。 bifurcateBy根据给定的函数将值分成两组，该函数可以指定输入数组中的元素属于哪个组。如果函数返回真，则集合元素属于第一组；否则，它属于第二组。 每个元素调用 fn 得到返回值，使用 Array.prototype.reduce()和 Array.prototype.push()将元素添加到组中。 1234567var init = [[], []] // 便于理解，我这里稍作修改const bifurcateBy = (arr, fn) =&gt; arr.reduce((acc, val, i) =&gt; (acc[fn(val, i) ? 0 : 1].push(val), acc), init)// 示例 ↓bifurcateBy(['beep', 'boop', 'foo', 'bar'], x =&gt; x[0] === 'b')// [ ['beep', 'boop', 'bar'], ['foo'] ] chunk将数组分成指定长度的多维数组。 使用 Array.from()创建一个新的数组，该数组的长度等于要生成的块的长度。使用 Array.prototype.slice()将新数组的元素映射到一个长度为给定长度的块。如果原数组不能被平均分割，则最后一块将包含剩余的元素。 1234567const chunk = (arr, size) =&gt; Array.from(&#123; length: Math.ceil(arr.length / size) &#125;, (v, i) =&gt; arr.slice(i * size, i * size + size) )// 示例 ↓chunk([1, 2, 3, 4, 5], 2) // [[1,2],[3,4],[5]] compact从数组中删除无效值。 使用 Array.prototype.filter()过滤掉无效值(false, null, 0, “”, undefined, NaN) 1234const compact = arr =&gt; arr.filter(Boolean)// 示例 ↓compact([0, 1, false, 2, '', 3, 'a', 'e' * 23, NaN, 's', 34]) // [ 1, 2, 3, 'a', 's', 34 ] countBy根据给定函数对数组中的元素进行分组，并返回每个组中元素总数。 使用 Array.prototype.map()返回数组元素调用函数或属性后的值。使用 Array.prototype.reduce()创建一个对象，其中键是根据前面的值生成的。 123456789const countBy = (arr, fn) =&gt; arr.map(typeof fn === 'function' ? fn : val =&gt; val[fn]).reduce((acc, val) =&gt; &#123; acc[val] = (acc[val] || 0) + 1 return acc &#125;, &#123;&#125;)// 示例 ↓countBy([6.1, 4.2, 6.3], Math.floor) // &#123;4: 1, 6: 2&#125;countBy(['one', 'two', 'three'], 'length') // &#123;3: 2, 5: 1&#125; countOccurrences计算数组中某个值的出现次数。 使用 Array.prototype.reduce()，每当遇到数组中的特定值时，递增计数器。 12345const countOccurrences = (arr, val) =&gt; arr.reduce((a, v) =&gt; (v === val ? a + 1 : a), 0)// 示例 ↓countOccurrences([1, 1, 2, 1, 2, 3], 1) // 3 deepFlatten将数组展平。 借助递归。使用 Array.prototype.concat 结合空数组([])和扩展运算符(…)来展平数组。递归展平作用于数组的每个元素。 12345const deepFlatten = arr =&gt; [].concat(...arr.map(v =&gt; (Array.isArray(v) ? deepFlatten(v) : v)))// 示例 ↓deepFlatten([1, [2], [[3], 4], 5]) // [1,2,3,4,5] difference返回两个数组之间的差异。 从 b 创建一个 Set，然后在 a 上使用 Array.prototype.filter()来只保留 b 中不包含的值。 1234567const difference = (a, b) =&gt; &#123; const s = new Set(b) // Set可以用于数组去重 return a.filter(x =&gt; !s.has(x))&#125;// 示例 ↓difference([1, 2, 3], [1, 2, 4]) // [3] differenceBy将给定的函数应用于两个数组的每个数组元素后，返回两个数组之间的差异。 通过对 b 中的每个元素调用 fn 来创建一个 Set，然后将 Array.protototype.filter()和 a 中元素调用 fn 的结果结合使用，只保留先前创建的集合中不包含的值。 12345678const differenceBy = (a, b, fn) =&gt; &#123; const s = new Set(b.map(fn)) return a.filter(x =&gt; !s.has(fn(x)))&#125;// 示例 ↓differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor) // [1.2]differenceBy([&#123; x: 2 &#125;, &#123; x: 1 &#125;], [&#123; x: 1 &#125;], v =&gt; v.x) // [ &#123; x: 2 &#125; ] differenceWith过滤得到数组在比较函数中不返回 true 的所有值。 使用 Array.prototype.filter()和 Array.prototype.findindex()查找适当的值。 1234567891011const differenceWith = (arr, val, comp) =&gt; arr.filter(a =&gt; val.findIndex(b =&gt; comp(a, b)) === -1)// 示例 ↓differenceWith( [1, 1.2, 1.5, 3, 0], [1.9, 3, 0], (a, b) =&gt; Math.round(a) === Math.round(b)) // [1, 1.2]// differenceBy可以做到同样的效果 drop返回一个从左边移除 n 个元素后的新数组。 使用 Array.prototype.slice()从左侧移除指定数量的元素。 123456const drop = (arr, n = 1) =&gt; arr.slice(n)// 示例 ↓drop([1, 2, 3]) // [2,3]drop([1, 2, 3], 2) // [3]drop([1, 2, 3], 42) // [] dropRight返回一个从右边移除 n 个元素后的新数组。 使用 Array.prototype.slice()从右侧移除指定数量的元素。 123456const drop = (arr, n = 1) =&gt; arr.slice(0, -n)// 示例 ↓dropRight([1, 2, 3]) // [1,2]dropRight([1, 2, 3], 2) // [1]dropRight([1, 2, 3], 42) // [] dropRightWhile从数组末尾移除元素，直到传递的函数返回 true。返回数组中的剩余元素。 使用 Array.protototype.slice()循环数组，直到函数返回值为 true。返回剩余元素。 1234567const dropRightWhile = (arr, func) =&gt; &#123; while (arr.length &gt; 0 &amp;&amp; !func(arr[arr.length - 1])) arr = arr.slice(0, -1) return arr&#125;// 示例 ↓dropRightWhile([1, 2, 3, 4], n =&gt; n &lt; 3) // [1, 2] dropWhile从数组开头移除元素，直到传递的函数返回 true。返回数组中的剩余元素。 循环数组，使用 Array.prototype.slice()删除数组的第一个元素，直到函数返回值为 true。返回剩余元素。 1234567const dropWhile = (arr, func) =&gt; &#123; while (arr.length &gt; 0 &amp;&amp; !func(arr[0])) arr = arr.slice(1) return arr&#125;// 示例 ↓dropWhile([1, 2, 3, 4], n =&gt; n &gt;= 3) // [3,4] everyNth返回数组中顺序为 nth 倍数的元素。 使用 Array.prototype.filter()创建一个新数组，该数组包含给定数组中顺序为 nth 倍数的元素。 1234const everyNth = (arr, nth) =&gt; arr.filter((e, i) =&gt; i % nth === nth - 1)// 示例 ↓everyNth([1, 2, 3, 4, 5, 6], 2) // [ 2, 4, 6 ] filterFalsy过滤掉数组中的错误值。 使用 array.prototype.filter（）获取只包含 truthy 值的数组。 12345const filterFalsy = arr =&gt; arr.filter(Boolean)// 示例 ↓filterFalsy(['', true, &#123;&#125;, false, 'sample', 1, 0])// [true, &#123;&#125;, 'sample', 1] filterNonUnique过滤掉数组中的非唯一值。 使用 Array.prototype.filter()创建包含唯一值的数组。 12345const filterNonUnique = arr =&gt; arr.filter(i =&gt; arr.indexOf(i) === arr.lastIndexOf(i))// 示例 ↓filterNonUnique([1, 2, 2, 3, 4, 4, 5]) // [1, 3, 5] filterNonUniqueBy基于提供的比较器函数过滤掉数组中的非唯一值。 基于比较器函数 fn，对只包含唯一值的数组使用 Array.prototype.filter()和 Array. prototype.every()。比较器函数接受四个参数：两个被比较元素的值及其索引。 1234567891011121314const filterNonUniqueBy = (arr, fn) =&gt; arr.filter((v, i) =&gt; arr.every((x, j) =&gt; (i === j) === fn(v, x, i, j)))// 示例 ↓filterNonUniqueBy( [ &#123; id: 0, value: 'a' &#125;, &#123; id: 1, value: 'b' &#125;, &#123; id: 2, value: 'c' &#125;, &#123; id: 1, value: 'd' &#125;, &#123; id: 0, value: 'e' &#125; ], (a, b) =&gt; a.id == b.id) // [ &#123; id: 2, value: 'c' &#125; ] findLast返回调用所给函数返回真值的最后一个元素。 使用 Array.prototype.filter()过滤 fn 返回假值的元素，使用 Array.prototype.pop()获取最后一个元素。 1234const findLast = (arr, fn) =&gt; arr.filter(fn).pop()// 示例 ↓findLast([1, 2, 3, 4], n =&gt; n % 2 === 1) // 3 findLastIndex返回调用所给函数返回真值的最后一个元素的索引。 使用 Array.prototype.map()将每个元素与其索引和值映射到一个数组。使用 Array.prototype.filter()过滤 fn 返回假值的元素，使用 Array.prototype.pop()获取最后一个元素。 12345678const findLastIndex = (arr, fn) =&gt; arr .map((val, i) =&gt; [i, val]) .filter(([i, val]) =&gt; fn(val, i, arr)) .pop()[0]// 示例 ↓findLastIndex([1, 2, 3, 4], n =&gt; n % 2 === 1) // 2 (index of the value 3) flatten将数组展平到指定的深度。 使用递归，对于每一深度级别，深度递减 1。使用 Array.prototype.reduce()和 Array.prototype.concat()合并元素或数组。一般情况下，如果深度等于 1 则停止递归。省略第二个参数，depth 仅展平到深度 1 (单个展平)。 12345678910const flatten = (arr, depth = 1) =&gt; arr.reduce( (a, v) =&gt; a.concat(depth &gt; 1 &amp;&amp; Array.isArray(v) ? flatten(v, depth - 1) : v), [] )// 示例 ↓flatten([1, [2], 3, 4]) // [1, 2, 3, 4]flatten([1, [2, [3, [4, 5], 6], 7], 8], 2) // [1, 2, 3, [4, 5], 6, 7, 8] forEachRight从数组的最后一个元素开始，为每个数组元素执行给定的函数。 使用 Array.protototype.slice(0)克隆给定的数组，使用 Array.protototype.reverse()反转数组，使用 Array.protototype.foreach()循环反向数组。 12345678const forEachRight = (arr, callback) =&gt; arr .slice(0) .reverse() .forEach(callback)// 示例 ↓forEachRight([1, 2, 3, 4], val =&gt; console.log(val)) // '4', '3', '2', '1' groupBy根据给定函数对数组元素进行分组。 使用 Array.prototype.map()对数组元素调用到函数或属性。使用 Array.protototype.reduce()创建一个对象，其中的键是根据前面结果生成的。 1234567891011const groupBy = (arr, fn) =&gt; arr .map(typeof fn === 'function' ? fn : val =&gt; val[fn]) .reduce((acc, val, i) =&gt; &#123; acc[val] = (acc[val] || []).concat(arr[i]) return acc &#125;, &#123;&#125;)// 示例 ↓groupBy([6.1, 4.2, 6.3], Math.floor) // &#123;4: [4.2], 6: [6.1, 6.3]&#125;groupBy(['one', 'two', 'three'], 'length') // &#123;3: ['one', 'two'], 5: ['three']&#125; head返回数组的第一个元素。 使用 arr[0]返回数组的第一个元素。 1234const head = arr =&gt; arr[0]// 示例 ↓head([1, 2, 3]) // 1 indexOfAll返回数组中 val 出现的所有索引。如果 val 从未出现，返回[]。 使用 Array.prototype.reduce()循环元素并存储匹配元素的索引。返回索引数组。 123456const indexOfAll = (arr, val) =&gt; arr.reduce((acc, el, i) =&gt; (el === val ? [...acc, i] : acc), [])// 示例 ↓indexOfAll([1, 2, 3, 1, 2, 3], 1) // [0,3]indexOfAll([1, 2, 3], 4) // [] initial返回数组除了最后一个以外的所有元素。 使用 arr.slice(0, -1)来返回除最后一个元素以外的所有元素。 1234const initial = arr =&gt; arr.slice(0, -1)// 示例 ↓initial([1, 2, 3]) // [1,2] initialize2DArray生成指定行列和值的二维数组。 使用 Array.prototype.map()生成 h 行长度为 w 并填入值的数组。如果没有给定值，则默认为 null。 12345const initialize2DArray = (w, h, val = null) =&gt; Array.from(&#123; length: h &#125;).map(() =&gt; Array.from(&#123; length: w &#125;).fill(val))// 示例 ↓initialize2DArray(2, 2, 0) // [[0,0], [0,0]] initializeArrayWithRange初始化一个数组，该数组包含指定范围内的数字，并且按照指定步长递增。 使用 Array.from()创建所需长度的数组(结束-开始+1)/步长，并在给定范围内用所需值填充数组。可以省略开始值默认是 0。也可以省略步长来使用默认值 1。 12345678910const initializeArrayWithRange = (end, start = 0, step = 1) =&gt; Array.from( &#123; length: Math.ceil((end - start + 1) / step) &#125;, (v, i) =&gt; i * step + start )// 示例 ↓initializeArrayWithRange(5) // [0,1,2,3,4,5]initializeArrayWithRange(7, 3) // [3,4,5,6,7]initializeArrayWithRange(9, 0, 2) // [0,2,4,6,8] initializeArrayWithRangeRight初始化一个数组，该数组包含指定范围内的数字（反向），并且按照指定步长递减。 使用 Array.from(Math.ceil((end+1-start)/step))创建所需长度的数组(长度等于(结束-开始)/步长或(结束+1-开始)/步长 (包含结束))，并在给定范围内用所需值填充数组。可以省略开始值默认是 0。也可以省略步长来使用默认值 1。 123456789const initializeArrayWithRangeRight = (end, start = 0, step = 1) =&gt; Array.from(&#123; length: Math.ceil((end + 1 - start) / step) &#125;).map( (v, i, arr) =&gt; (arr.length - i - 1) * step + start )// 示例 ↓initializeArrayWithRangeRight(5) // [5,4,3,2,1,0]initializeArrayWithRangeRight(7, 3) // [7,6,5,4,3]initializeArrayWithRangeRight(9, 0, 2) // [8,6,4,2,0] initializeArrayWithValues用指定的值初始化并填充数组。 使用 Array(n)创建所需长度的数组，用 fill(v) 根据所需值填充数组(v)。你可以省略 val 来使用默认值 0。 1234const initializeArrayWithValues = (n, val = 0) =&gt; Array(n).fill(val)// 示例 ↓initializeArrayWithValues(5, 2) // [2, 2, 2, 2, 2] initializeNDArray创建具有给定值的 n 维数组。 使用递归。用 Array.prototype.map()生成行数组，其中每一行都是使用 initializendaray 初始化的新数组。 12345678910const initializeNDArray = (val, ...args) =&gt; args.length === 0 ? val : Array.from(&#123; length: args[0] &#125;).map(() =&gt; initializeNDArray(val, ...args.slice(1)) )// 示例 ↓initializeNDArray(1, 3) // [1,1,1]initializeNDArray(5, 2, 2, 2) // [[[5,5],[5,5]],[[5,5],[5,5]]] intersection返回两个数组中都存在的元素数组。 从 b 创建一个集合，然后在 a 上使用 Array.prototype.filter()来只保留 b 中包含的值。 1234567const intersection = (a, b) =&gt; &#123; const s = new Set(b) return a.filter(x =&gt; s.has(x))&#125;// 示例 ↓intersection([1, 2, 3], [4, 3, 2]) // [2, 3] intersectionBy将给定的函数应用于两个数组中的每个数组元素后，返回执行函数后第一个数组和第二个数组中相同的值。 b 中的所有元素执行 fn 后创建一个集合，然后在 a 上使用 Array.prototype.filter()来保留将执行 fn 后结果在 b 中的元素。 1234567const intersectionBy = (a, b, fn) =&gt; &#123; const s = new Set(b.map(fn)) return a.filter(x =&gt; s.has(fn(x)))&#125;// 示例 ↓intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor) // [2.1] intersectionWith使用给定的函数返回两个数组中都通过的元素数组。 使用 Array.prototype.filter()和 Array.prototype.findindex()与所提供的函数结合使用来确定公共值。 123456789const intersectionWith = (a, b, comp) =&gt; a.filter(x =&gt; b.findIndex(y =&gt; comp(x, y)) !== -1)// 示例 ↓intersectionWith( [1, 1.2, 1.5, 3, 0], [1.9, 3, 0, 3.9], (a, b) =&gt; Math.round(a) === Math.round(b)) // [1.5, 3, 0] isSorted如果数组按升序排序，则返回 1；如果数组按降序排序，则返回-1；如果数组未排序，则返回 0。 计算前两个元素的排序方向。使用 Object.entries()循环数组元素并成对比较它们。如果方向改变，返回 0；如果到达最后一个元素，返回排序方向。 12345678910111213const isSorted = arr =&gt; &#123; let direction = -(arr[0] - arr[1]) for (let [i, val] of arr.entries()) &#123; direction = !direction ? -(arr[i - 1] - arr[i]) : direction if (i === arr.length - 1) return !direction ? 0 : direction else if ((val - arr[i + 1]) * direction &gt; 0) return 0 &#125;&#125;// 示例 ↓isSorted([0, 1, 2, 2]) // 1isSorted([4, 3, 2]) // -1isSorted([4, 3, 5]) // 0 join将数组中的所有元素连接成一个字符串并返回该字符串。使用起始分隔符和末端分隔符。 使用 Array.prototype.reduce()将元素组合成一个字符串。省略第二个参数 separator 时，将使用,作为默认分隔符。省略第三个参数 end 时，默认情况下使用与 separator 相同的值分隔。 123456789101112131415const join = (arr, separator = ',', end = separator) =&gt; arr.reduce( (acc, val, i) =&gt; i === arr.length - 2 ? acc + val + end : i === arr.length - 1 ? acc + val : acc + val + separator, '' )// 示例 ↓join(['pen', 'pineapple', 'apple', 'pen'], ',', '&amp;') // "pen,pineapple,apple&amp;pen"join(['pen', 'pineapple', 'apple', 'pen'], ',') // "pen,pineapple,apple,pen"join(['pen', 'pineapple', 'apple', 'pen']) // "pen,pineapple,apple,pen" JSONtoCSV将对象数组转换为仅包含指定 columns 的逗号分隔值(CSV)字符串。 使用 Array.prototype.join(分隔符)将 columns 中的所有名称组合起来，创建第一行。使用 Array.prototype.map()和 Array.prototype.reduce()为每个对象创建一行，用空字符串替换不存在的值，只映射 columns 中的值。使用 Array.prototype.join(‘\n’)将所有行组合成一个字符串。省略第三个参数 delimiter，将会使用默认分隔符,。 12345678910111213141516171819202122const JSONtoCSV = (arr, columns, delimiter = ',') =&gt; [ columns.join(delimiter), ...arr.map(obj =&gt; columns.reduce( (acc, key) =&gt; `$&#123;acc&#125;$&#123;!acc.length ? '' : delimiter&#125;"$&#123;!obj[key] ? '' : obj[key]&#125;"`, '' ) ) ].join('\n')// 示例 ↓JSONtoCSV( [&#123; a: 1, b: 2 &#125;, &#123; a: 3, b: 4, c: 5 &#125;, &#123; a: 6 &#125;, &#123; b: 7 &#125;], ['a', 'b']) // 'a,b\n"1","2"\n"3","4"\n"6",""\n"","7"'JSONtoCSV( [&#123; a: 1, b: 2 &#125;, &#123; a: 3, b: 4, c: 5 &#125;, &#123; a: 6 &#125;, &#123; b: 7 &#125;], ['a', 'b'], ';') // 'a;b\n"1";"2"\n"3";"4"\n"6";""\n"";"7"' last返回数组中最后一个元素。 使用 arr.length - 1 计算给定数组的最后一个元素的索引并返回它。 1234const last = arr =&gt; arr[arr.length - 1]// 示例 ↓last([1, 2, 3]) // 3 longestItem获取任意数量的可迭代对象或具有 length 属性的对象，并返回最长的对象。如果多个对象具有相同的长度，则将返回第一个对象。如果未提供参数，则返回 undefined。 使用 Array.prototype.reduce()，比较对象的长度以找到最长的对象。 123456789const longestItem = (...vals) =&gt; vals.reduce((a, x) =&gt; (x.length &gt; a.length ? x : a))// 示例 ↓longestItem('this', 'is', 'a', 'testcase') // 'testcase'longestItem(...['a', 'ab', 'abc']) // 'abc'longestItem(...['a', 'ab', 'abc'], 'abcd') // 'abcd'longestItem([1, 2, 3], [1, 2], [1, 2, 3, 4, 5]) // [1, 2, 3, 4, 5]longestItem([1, 2, 3], 'foobar') // 'foobar' mapObject使用函数将数组的值映射到对象，其中键值对使用原始值作为键和计算后的映射值。 使用匿名内部函数声明未定义的内存空间，使用闭包存储返回值。使用一个新数组存储数组，新数组包含函数在传入数组上的映射，并使用逗号运算符返回第二步，而无需从一个上下文移动到另一个上下文(由于闭包和操作顺序)。 123456789const mapObject = (arr, fn) =&gt; (a =&gt; ( (a = [arr, arr.map(fn)]), a[0].reduce((acc, val, ind) =&gt; ((acc[val] = a[1][ind]), acc), &#123;&#125;) ))()// 示例 ↓const squareIt = arr =&gt; mapObject(arr, a =&gt; a * a)squareIt([1, 2, 3]) // &#123; 1: 1, 2: 4, 3: 9 &#125; maxN从提供的数组中返回 n 个最大的元素。如果 n 大于或等于提供的数组长度，则返回原始数组(按降序排序)。 将 Array.prototype.sort()与扩展运算符(…)结合使用浅拷贝数组并按降序排序。使用 Array.prototype.slice()获取指定数量的元素。省略第二个参数 n，得到只有一个元素的数组。 12345const maxN = (arr, n = 1) =&gt; [...arr].sort((a, b) =&gt; b - a).slice(0, n)// 示例 ↓maxN([1, 2, 3]) // [3]maxN([1, 2, 3], 2) // [3,2] minN从提供的数组中返回 n 个最小的元素。如果 n 大于或等于提供的数组长度，则返回原始数组(按升序排序)。 将 Array.prototype.sort()与扩展运算符(…)结合使用浅拷贝数组并按升序排序。使用 Array.prototype.slice()获取指定数量的元素。省略第二个参数 n，得到只有一个元素的数组。 12345const minN = (arr, n = 1) =&gt; [...arr].sort((a, b) =&gt; a - b).slice(0, n)// 示例 ↓minN([1, 2, 3]) // [1]minN([1, 2, 3], 2) // [1,2] none如果集合中的所有元素执行给定的函数后都返回 false，则返回 true，否则返回 false。 使用 Array.prototype.some()测试集合中的任何元素是否基于 fn 返回 true。省略第二个参数 fn，将使用 Boolean 作为默认值。 12345const none = (arr, fn = Boolean) =&gt; !arr.some(fn)// 示例 ↓none([0, 1, 3, 0], x =&gt; x == 2) // truenone([0, 0, 0]) // true nthElement返回数组的第 n 个元素。 使用 Array.prototype.slice()首先获得包含第 n 个元素的数组。如果索引超出范围，则返回 undefined。省略第二个参数 n，取数组的第一个元素。 12345onst nthElement = (arr, n = 0) =&gt; (n === -1 ? arr.slice(n) : arr.slice(n, n + 1))[0];// 示例 ↓nthElement(['a', 'b', 'c'], 1); // 'b'nthElement(['a', 'b', 'b'], -3); // 'a' offset将指定数量的元素移动到数组的末尾或头部。 使用两次 Array.prototype.slice()获得指定索引之后的元素和指定索引之前的元素。使用扩展运算符(…)将两者组合成一个数组。如果 offset 为负数，则元素将从尾部移动到头部。 12345const offset = (arr, offset) =&gt; [...arr.slice(offset), ...arr.slice(0, offset)]// 示例 ↓offset([1, 2, 3, 4, 5], 2) // [3, 4, 5, 1, 2]offset([1, 2, 3, 4, 5], -2) // [4, 5, 1, 2, 3] partition根据每个元素执行函数后返回的布尔值，将元素分成两类数组。 使用 Array.prototype.reduce()创建一个由两个数组组成的数组。使用 Array.prototype.push()将 fn 返回 true 的元素添加到第一个数组，将 fn 返回 false 的元素添加到第二个数组。 123456789101112131415161718const partition = (arr, fn) =&gt; arr.reduce( (acc, val, i, arr) =&gt; &#123; acc[fn(val, i, arr) ? 0 : 1].push(val) return acc &#125;, [[], []] )// 示例 ↓const users = [ &#123; user: 'barney', age: 36, active: false &#125;, &#123; user: 'fred', age: 40, active: true &#125;]partition(users, o =&gt; o.active)[ // ([&#123; user: 'fred', age: 40, active: true &#125;], // [&#123; user: 'barney', age: 36, active: false &#125;])] permutations警告：这个函数的执行时间随着数组元素的增加呈指数增长。当浏览器试图计算所有不同的组合时，超过 8 到 10 个条目都会导致浏览器挂起。 生成数组元素的所有组合(包含重复元素)。 使用递归。对给定数组中进行元素遍历，为剩余元素创建所有的组合。使用 Array.prototype.map()将该元素与剩余部分排列组合起来，然后使用 Array.prototype.reduce()将所有排列组合成一个数组。一般情况是数组长度为 2 或 1。 1234567891011121314151617const permutations = arr =&gt; &#123; if (arr.length &lt;= 2) return arr.length === 2 ? [arr, [arr[1], arr[0]]] : arr return arr.reduce( (acc, item, i) =&gt; acc.concat( permutations([...arr.slice(0, i), ...arr.slice(i + 1)]).map(val =&gt; [ item, ...val ]) ), [] )&#125;// 示例 ↓permutations([1, 33, 5])// [[1, 33, 5], [1, 5, 33], [33, 1, 5], [33, 5, 1], [5, 1, 33], [5, 33, 1]] pull变异原数组以过滤掉指定的值。 使用 Array.prototype.filter()和 Array.prototype.include()提取不需要的值。使用 Array.protototype.length = 0 将将数组的长度重置为零来对数组中传递的值进行变异，并使用 Array.prototype.push()重新填充该值。 (对于不改变原始数组的代码片段，请参见 without) 12345678910const pull = (arr, ...args) =&gt; &#123; let argState = Array.isArray(args[0]) ? args[0] : args let pulled = arr.filter((v, i) =&gt; !argState.includes(v)) arr.length = 0 pulled.forEach(v =&gt; arr.push(v))&#125;// 示例 ↓let myArray = ['a', 'b', 'c', 'a', 'b', 'c']pull(myArray, 'a', 'c') // myArray = [ 'b', 'b' ] pullAtIndex变异原数组以筛选出指定索引处的值。 使用 Array.prototype.filter()和 Array.prototype.include()提取不需要的值。使用 Array.protototype.length = 0 将数组的长度重置为零来对数组中传递的值进行变异，并使用 Array.prototype.push()重新填充该值。使用 Array.prototype.push()来跟踪所提取的值。 1234567891011121314const pullAtIndex = (arr, pullArr) =&gt; &#123; let removed = [] let pulled = arr .map((v, i) =&gt; (pullArr.includes(i) ? removed.push(v) : v)) .filter((v, i) =&gt; !pullArr.includes(i)) arr.length = 0 pulled.forEach(v =&gt; arr.push(v)) return removed&#125;// 示例 ↓let myArray = ['a', 'b', 'c', 'd']let pulled = pullAtIndex(myArray, [1, 3])// myArray = [ 'a', 'c' ] , pulled = [ 'b', 'd' ] pullAtValue变异原数组以过滤掉指定的值。返回删除的元素。 使用 Array.prototype.filter()和 Array.prototype.include()提取不需要的值。使用 Array.protototype.length = 0 将数组的长度重置为零来对数组中传递的值进行变异，并使用 Array.prototype.push()重新填充该值。使用 Array.prototype.push()来跟踪所提取的值。 123456789101112131415const pullAtValue = (arr, pullArr) =&gt; &#123; let removed = [], pushToRemove = arr.forEach((v, i) =&gt; pullArr.includes(v) ? removed.push(v) : v ), mutateTo = arr.filter((v, i) =&gt; !pullArr.includes(v)) arr.length = 0 mutateTo.forEach(v =&gt; arr.push(v)) return removed&#125;// 示例 ↓let myArray = ['a', 'b', 'c', 'd']let pulled = pullAtValue(myArray, ['b', 'd'])// myArray = [ 'a', 'c' ] , pulled = [ 'b', 'd' ] pullBy基于给定的迭代函数，对原始数组进行变异以过滤掉指定的值。 检查函数中是否提供了最后一个参数。使用 Array.prototype.map()将迭代函数 fn 应用于所有数组元素。使用 Array.prototype.filter()和 Array.prototype.include()提取不需要的值。使用 Array.protototype.length = 0 将数组的长度重置为零来对数组中传递的值进行变异，并使用 Array.prototype.push()重新填充该值。 12345678910111213const pullBy = (arr, ...args) =&gt; &#123; const length = args.length let fn = length &gt; 1 ? args[length - 1] : undefined fn = typeof fn == 'function' ? (args.pop(), fn) : undefined let argState = (Array.isArray(args[0]) ? args[0] : args).map(val =&gt; fn(val)) let pulled = arr.filter((v, i) =&gt; !argState.includes(fn(v))) arr.length = 0 pulled.forEach(v =&gt; arr.push(v))&#125;// 示例 ↓var myArray = [&#123; x: 1 &#125;, &#123; x: 2 &#125;, &#123; x: 3 &#125;, &#123; x: 1 &#125;]pullBy(myArray, [&#123; x: 1 &#125;, &#123; x: 3 &#125;], o =&gt; o.x) // myArray = [&#123; x: 2 &#125;] reducedFilter基于条件过滤对象数组，同时过滤掉未指定的键。 使用 Array.prototype.filter()根据函数 fn 过滤数组，返回满足条件的对象。在过滤后的数组上，使用 Array.prototype.map()返回新对象，使用 Array.prototype.reduce()过滤掉未作为键参数提供的键。 123456789101112131415161718192021222324const reducedFilter = (data, keys, fn) =&gt; data.filter(fn).map(el =&gt; keys.reduce((acc, key) =&gt; &#123; acc[key] = el[key] return acc &#125;, &#123;&#125;) )// 示例 ↓const data = [ &#123; id: 1, name: 'john', age: 24 &#125;, &#123; id: 2, name: 'mike', age: 50 &#125;]reducedFilter(data, ['id', 'name'], item =&gt; item.age &gt; 24)// [&#123; id: 2, name: 'mike'&#125;] reduceSuccessive对累加器和数组中的每个元素应用一个函数(从左到右)，返回一个值变大的数组。 使用 Array.prototype.reduce()将给定的函数应用于数组，存储每个新的结果。 12345678const reduceSuccessive = (arr, fn, acc) =&gt; arr.reduce( (res, val, i, arr) =&gt; (res.push(fn(res.slice(-1)[0], val, i, arr)), res), [acc] )// 示例 ↓reduceSuccessive([1, 2, 3, 4, 5, 6], (acc, val) =&gt; acc + val, 0) // [0, 1, 3, 6, 10, 15, 21] reduceWhich应用提供的函数设置比较规则后，返回数组的最小值/最大值。 将 Array.prototype.reduce()与 comparator 函数结合使用，在数组中取得对应的元素。可以省略第二个参数，使用返回数组中最小元素作为默认参数。 123456789101112131415// 简直精髓const reduceWhich = (arr, comparator = (a, b) =&gt; a - b) =&gt; arr.reduce((a, b) =&gt; (comparator(a, b) &gt;= 0 ? b : a))// 示例 ↓reduceWhich([1, 3, 2]) // 1reduceWhich([1, 3, 2], (a, b) =&gt; b - a) // 3reduceWhich( [ &#123; name: 'Tom', age: 12 &#125;, &#123; name: 'Jack', age: 18 &#125;, &#123; name: 'Lucy', age: 9 &#125; ], (a, b) =&gt; a.age - b.age) // &#123;name: "Lucy", age: 9&#125; reject接收函数和数组，使用 Array.prototype.Filter()，但仅在 pred(x) = false 时保留 x。 12345const reject = (pred, array) =&gt; array.filter((...args) =&gt; !pred(...args))// 示例 ↓reject(x =&gt; x % 2 === 0, [1, 2, 3, 4, 5]) // [1, 3, 5]reject(word =&gt; word.length &gt; 4, ['Apple', 'Pear', 'Kiwi', 'Banana']) // ['Pear', 'Kiwi'] remove从数组中移除给定函数返回 false 的元素。 使用 Array.prototype.filter()查找返回真值的数组元素，使用 Array.prototype.splice()删除元素。函数是用三个参数(值、索引、数组)调用的。 12345678910const remove = (arr, func) =&gt; Array.isArray(arr) ? arr.filter(func).reduce((acc, val) =&gt; &#123; arr.splice(arr.indexOf(val), 1) return acc.concat(val) &#125;, []) : []// 示例 ↓remove([1, 2, 3, 4], n =&gt; n % 2 === 0) // [2, 4] sample从数组中返回随机元素 使用 Math.random()生成一个随机数，并乘上数组长度，然后使用 Math.floor()向下取整。这个方法也适用于字符串。 1234const sample = arr =&gt; arr[Math.floor(Math.random() * arr.length)]// 示例 ↓sample([3, 7, 9, 11]) // 9 sampleSize从数组中以唯一键获取 n 个随机元素，直到数组结束。 使用 Fisher-Yates 算法洗牌数组。使用 Array.prototype.slice()获得前 n 个元素。省略第二个参数 n，从数组中获取第一个元素。 123456789101112const sampleSize = ([...arr], n = 1) =&gt; &#123; let m = arr.length while (m) &#123; const i = Math.floor(Math.random() * m--) ;[arr[m], arr[i]] = [arr[i], arr[m]] &#125; return arr.slice(0, n)&#125;// 示例 ↓sampleSize([1, 2, 3], 2) // [3,1]sampleSize([1, 2, 3], 4) // [2,3,1] shank和 Array.prototype.splice()功能相同，但是返回一个新的数组，而不是改变原始数组。 在移除现有元素/添加新元素后，使用 Array.prototype.slice()和 Array.prototype .concat()获得包含新内容的新数组。省略第二个参数 index，则从 0 开始。省略第三个参数 DelCount，不删除元素。省略第四个参数元素，不添加新元素。 1234567891011const shank = (arr, index = 0, delCount = 0, ...elements) =&gt; arr .slice(0, index) .concat(elements) .concat(arr.slice(index + delCount))// 示例 ↓const names = ['alpha', 'bravo', 'charlie']const namesAndDelta = shank(names, 1, 0, 'delta') // [ 'alpha', 'delta', 'bravo', 'charlie' ]const namesNoBravo = shank(names, 1, 1) // [ 'alpha', 'charlie' ]console.log(names) // ['alpha', 'bravo', 'charlie'] shuffle随机排列数组值的顺序，返回一个新数组。 使用 Fisher-Yates 算法对数组元素重新排序。 123456789101112const shuffle = ([...arr]) =&gt; &#123; let m = arr.length while (m) &#123; const i = Math.floor(Math.random() * m--) ;[arr[m], arr[i]] = [arr[i], arr[m]] &#125; return arr&#125;// 示例 ↓const foo = [1, 2, 3]shuffle(foo) // [2, 3, 1], foo = [1, 2, 3] similarity返回出现在两个数组中的元素数组。 使用 Array.prototype.filter()过滤非公共值，这些值是由 Array.prototype .include()确定的。 12345const similarity = (arr, values) =&gt; arr.filter(v =&gt; values.includes(v))// 示例 ↓similarity([1, 2, 3], [1, 2, 4])// [1, 2] sortedIndex将指定值插入到数组中，保持其排序顺序的最左侧。 检查数组是否按降序（松散地）排序。 使用 Array.findIndex() 来找到元素应该被插入的合适的索引位置。 123456789const sortedIndex = (arr, n) =&gt; &#123; const isDescending = arr[0] &gt; arr[arr.length - 1] const index = arr.findIndex(el =&gt; (isDescending ? n &gt;= el : n &lt;= el)) return index === -1 ? arr.length : index&#125;// 示例 ↓sortedIndex([5, 3, 2, 1], 4) // 1sortedIndex([30, 50], 40) // 1 sortedIndexBy根据提供的迭代器函数，将指定值插入数组，保持其排序顺序的最左侧。 检查数组是否按降序（松散）排序。根据迭代器函数 fn，使用 array.prototype.find index（）查找应在其中插入元素的适当索引。 1234567891011const sortedIndexBy = (arr, n, fn) =&gt; &#123; const isDescending = fn(arr[0]) &gt; fn(arr[arr.length - 1]) const val = fn(n) const index = arr.findIndex(el =&gt; isDescending ? val &gt;= fn(el) : val &lt;= fn(el) ) return index === -1 ? arr.length : index&#125;// 示例 ↓sortedIndexBy([&#123; x: 4 &#125;, &#123; x: 5 &#125;], &#123; x: 4 &#125;, o =&gt; o.x) // 0 sortedLastIndex将指定值插入数组，保持其排序顺序的最右侧。 检查数组是否按降序（松散）排序。使用 array.prototype.reverse（）和 array.prototype.find index（）找到元素应该插入的最后一个索引。 12345678910const sortedLastIndex = (arr, n) =&gt; &#123; const isDescending = arr[0] &gt; arr[arr.length - 1] const index = arr .reverse() .findIndex(el =&gt; (isDescending ? n &lt;= el : n &gt;= el)) return index === -1 ? 0 : arr.length - index&#125;// 示例 ↓sortedLastIndex([10, 20, 30, 30, 40], 30) // 4 sortedLastIndexBy根据提供的迭代器函数，将指定值插入数组，保持其排序顺序的最右侧。 检查数组是否按降序（松散）排序。使用 array.prototype.map（）将迭代器函数应用于数组的所有元素。根据提供的迭代器函数，使用 array.prototype.reverse（）和 array.prototype.find index（）查找元素应插入的最后一个适当索引。 123456789101112const sortedLastIndexBy = (arr, n, fn) =&gt; &#123; const isDescending = fn(arr[0]) &gt; fn(arr[arr.length - 1]) const val = fn(n) const index = arr .map(fn) .reverse() .findIndex(el =&gt; (isDescending ? val &lt;= el : val &gt;= el)) return index === -1 ? 0 : arr.length - index&#125;// 示例 ↓sortedLastIndexBy([&#123; x: 4 &#125;, &#123; x: 5 &#125;], &#123; x: 4 &#125;, o =&gt; o.x) // 1 symmetricDifference返回两个数组之间的差集。 根据每个数组创建一个 Set ，然后在每个数组上使用 Array.filter() ，只保留另一个数组不包含的值。 123456789const symmetricDifference = (a, b) =&gt; &#123; const sA = new Set(a), sB = new Set(b) return [...a.filter(x =&gt; !sB.has(x)), ...b.filter(x =&gt; !sA.has(x))]&#125;// 示例 ↓symmetricDifference([1, 2, 3], [1, 2, 4]) // [3, 4]symmetricDifference([1, 2, 2], [1, 3, 1]) // [2, 2, 3] symmetricDifferenceBy将提供的函数应用于两个数组的每个数组元素后，返回两个数组之间的差集。 通过对每个数组的元素应用 fn 创建一个集合，然后对每个元素使用 array.prototype.filter（）来只保留不包含在另一个数组中的值。 12345678const symmetricDifferenceBy = (a, b, fn) =&gt; &#123; const sA = new Set(a.map(v =&gt; fn(v))), sB = new Set(b.map(v =&gt; fn(v))) return [...a.filter(x =&gt; !sB.has(fn(x))), ...b.filter(x =&gt; !sA.has(fn(x)))]&#125;// 示例 ↓symmetricDifferenceBy([2.1, 1.2], [2.3, 3.4], Math.floor) // [ 1.2, 3.4 ] symmetricDifferenceWith使用提供的函数作为比较器返回两个数组之间的差集。 使用 array.prototype.filter（）和 array.prototype.findindex（）查找适当的值。 1234567891011const symmetricDifferenceWith = (arr, val, comp) =&gt; [ ...arr.filter(a =&gt; val.findIndex(b =&gt; comp(a, b)) === -1), ...val.filter(a =&gt; arr.findIndex(b =&gt; comp(a, b)) === -1)]// 示例 ↓symmetricDifferenceWith( [1, 1.2, 1.5, 3, 0], [1.9, 3, 0, 3.9], (a, b) =&gt; Math.round(a) === Math.round(b)) // [1, 1.2, 3.9] tail返回数组中除第一个元素外的所有元素。 如果数组的 length 大于 1 ，则返回 Array.slice(1)，否则返回整个数组。 12345const tail = arr =&gt; (arr.length &gt; 1 ? arr.slice(1) : arr)// 示例 ↓tail([1, 2, 3]) // [2,3]tail([1]) // [1] take创建一个数组切片，从 arr 数组的起始元素开始提取 n 个元素。 使用 Array.slice() 创建一个数组包含第一个元素开始，到 n 个元素结束的数组。 12345const take = (arr, n = 1) =&gt; arr.slice(0, n)// 示例 ↓take([1, 2, 3], 5) // [1, 2, 3]take([1, 2, 3], 0) // [] takeRight创建一个数组切片，从 arr 数组的最后一个元素开始向前提取 n 个元素。 使用 Array.slice() 来创建一个从第 n 个元素开始从末尾的数组。 12345const takeRight = (arr, n = 1) =&gt; arr.slice(arr.length - n, arr.length)// 示例 ↓takeRight([1, 2, 3], 2) // [ 2, 3 ]takeRight([1, 2, 3]) // [3] takeRightWhile从数组末尾移除元素，直到传递的函数返回 true。返回删除的元素。 使用 array.prototype.reducceright（）循环数组，并在函数返回错误值时累积元素。 12345const takeRightWhile = (arr, func) =&gt; arr.reduceRight((acc, el) =&gt; (func(el) ? acc : [el, ...acc]), [])// 示例 ↓takeRightWhile([1, 2, 3, 4], n =&gt; n &lt; 3) // [3, 4] takeWhile移除数组中的元素，直到传递的函数返回 true。返回删除的元素。 循环数组，使用 for…of 循环 over array.prototype.entries（），直到函数返回的值为 true。使用 array.prototype.slice（）返回删除的元素。 1234567const takeWhile = (arr, func) =&gt; &#123; for (const [i, val] of arr.entries()) if (func(val)) return arr.slice(0, i) return arr&#125;// 示例 ↓takeWhile([1, 2, 3, 4], n =&gt; n &gt;= 3) // [1, 2] toHash将给定数组简化为值哈希（keyed data store）。 给定一个 iterable 或类似数组的结构，对所提供的对象调用 array.prototype.reduce.call（）以跳过它并返回一个由引用值键控的对象。 12345678910111213141516171819202122232425const toHash = (object, key) =&gt; Array.prototype.reduce.call( object, (acc, data, index) =&gt; ((acc[!key ? index : data[key]] = data), acc), &#123;&#125; )// 示例 ↓toHash([4, 3, 2, 1]) // &#123; 0: 4, 1: 3, 2: 2, 3: 1 &#125;toHash([&#123; a: 'label' &#125;], 'a') // &#123; label: &#123; a: 'label' &#125; &#125;// A more in depth example:let users = [ &#123; id: 1, first: 'Jon' &#125;, &#123; id: 2, first: 'Joe' &#125;, &#123; id: 3, first: 'Moe' &#125;]let managers = [&#123; manager: 1, employees: [2, 3] &#125;]// We use function here because we want a bindable reference, but a closure referencing the hash would work, too.managers.forEach( manager =&gt; (manager.employees = manager.employees.map(function(id) &#123; return this[id] &#125;, toHash(users, 'id'))))managers // [ &#123; manager:1, employees: [ &#123; id: 2, first: "Joe" &#125;, &#123; id: 3, first: "Moe" &#125; ] &#125; ] union返回两个数组中的任何一个元素(没有重复的)。 用数组 a 和 b 的所有值创建一个 Set 对象，并转换成一个数组。 1234const union = (a, b) =&gt; Array.from(new Set([...a, ...b]))// 示例 ↓union([1, 2, 3], [4, 3, 2]) // [1,2,3,4] unionBy将提供的函数应用于两个数组的每个数组元素之后，返回两个数组中任何一个元素(没有重复的)。 通过将所有 fn 应用于 a 的所有值来创建集合。从 a 和 b 中的所有元素创建集合，在应用 fn 之后，这些元素的值与以前创建的集合中的值不匹配。返回最后一个转换为数组的集合。 1234567const unionBy = (a, b, fn) =&gt; &#123; const s = new Set(a.map(fn)) return Array.from(new Set([...a, ...b.filter(x =&gt; !s.has(fn(x)))]))&#125;// 示例 ↓unionBy([2.1], [1.2, 2.3], Math.floor) // [2.1, 1.2] unionWith使用提供的比较器函数，返回两个数组中任何一个数组中存在的每个元素一次。 使用 array.prototype.findindex（）创建一个集合，其中 a 的所有值和 b 中的值都是比较器在 a 中找不到匹配项的。 123456789101112const unionWith = (a, b, comp) =&gt; Array.from( new Set([...a, ...b.filter(x =&gt; a.findIndex(y =&gt; comp(x, y)) === -1)]) )// 示例 ↓unionWith( [1, 1.2, 1.5, 3, 0], [1.9, 3, 0, 3.9], (a, b) =&gt; Math.round(a) === Math.round(b))// [1, 1.2, 1.5, 3, 0, 3.9] uniqueElements返回数组的所有唯一值，去重。 使用 es6 set 和…rest 运算符放弃所有重复的值。 1234const uniqueElements = arr =&gt; [...new Set(arr)]// 示例 ↓uniqueElements([1, 2, 2, 3, 4, 4, 5]) // [1, 2, 3, 4, 5] uniqueElementsBy基于提供的比较器函数返回数组的所有唯一值。 使用 array.prototype.reduce（）和 array.prototype.some（）表示一个数组，该数组只包含每个值的第一次唯一出现，基于 comparator 函数 fn。comparator 函数接受两个参数：被比较的两个元素的值。 1234567891011121314151617const uniqueElementsBy = (arr, fn) =&gt; arr.reduce((acc, v) =&gt; &#123; if (!acc.some(x =&gt; fn(v, x))) acc.push(v) return acc &#125;, [])// 示例 ↓uniqueElementsBy( [ &#123; id: 0, value: 'a' &#125;, &#123; id: 1, value: 'b' &#125;, &#123; id: 2, value: 'c' &#125;, &#123; id: 1, value: 'd' &#125;, &#123; id: 0, value: 'e' &#125; ], (a, b) =&gt; a.id == b.id) // [ &#123; id: 0, value: 'a' &#125;, &#123; id: 1, value: 'b' &#125;, &#123; id: 2, value: 'c' &#125; ] uniqueElementsByRight基于提供的比较器函数返回数组的所有唯一值。 使用 array.prototype.reduce（）和 array.prototype.some（）对仅包含每个值最后一次唯一出现的数组（基于 comparator 函数 fn）。comparator 函数接受两个参数：被比较的两个元素的值。 12345678910const uniqueSymmetricDifference = (a, b) =&gt; [ ...new Set([ ...a.filter(v =&gt; !b.includes(v)), ...b.filter(v =&gt; !a.includes(v)) ])]// 示例 ↓uniqueSymmetricDifference([1, 2, 3], [1, 2, 4]) // [3, 4]uniqueSymmetricDifference([1, 2, 2], [1, 3, 1]) // [2, 3] uniqueSymmetricDifference返回两个数组之间的差集，不包含来自任一数组的重复值。 在每个数组上使用 array.prototype.filter（）和 array.prototype.includes（）删除另一个数组中包含的值，然后根据结果创建一个集合，删除重复的值。 12345678910const uniqueSymmetricDifference = (a, b) =&gt; [ ...new Set([ ...a.filter(v =&gt; !b.includes(v)), ...b.filter(v =&gt; !a.includes(v)) ])]// 示例 ↓uniqueSymmetricDifference([1, 2, 3], [1, 2, 4]) // [3, 4]uniqueSymmetricDifference([1, 2, 2], [1, 3, 1]) // [2, 3] unzip创建数组数组，取消对由 zip 生成的数组中的元素的分组。 使用 math.max.apply（）获取数组中最长的子数组 array.prototype.map（）使每个元素成为数组。使用 array.prototype.reduce（）和 array.prototype.foreach（）将分组值映射到单个数组。 1234567891011const unzip = arr =&gt; arr.reduce( (acc, val) =&gt; (val.forEach((v, i) =&gt; acc[i].push(v)), acc), Array.from(&#123; length: Math.max(...arr.map(x =&gt; x.length)) &#125;).map(x =&gt; []) )// 示例 ↓unzip([['a', 1, true], ['b', 2, false]]) // [['a', 'b'], [1, 2], [true, false]]unzip([['a', 1, true], ['b', 2]]) // [['a', 'b'], [1, 2], [true]] unzipWith创建元素数组，取消对由 zip 生成的数组中的元素的分组，并应用提供的函数。 使用 math.max.apply（）获取数组中最长的子数组 array.prototype.map（）使每个元素成为数组。使用 array.prototype.reduce（）和 array.prototype.foreach（）将分组值映射到单个数组。使用 array.prototype.map（）和 spread 运算符（…）将 fn 应用于每个单独的元素组。 1234567891011121314const unzipWith = (arr, fn) =&gt; arr .reduce( (acc, val) =&gt; (val.forEach((v, i) =&gt; acc[i].push(v)), acc), Array.from(&#123; length: Math.max(...arr.map(x =&gt; x.length)) &#125;).map(x =&gt; []) ) .map(val =&gt; fn(...val))// 示例 ↓unzipWith([[1, 10, 100], [2, 20, 200]], (...args) =&gt; args.reduce((acc, v) =&gt; acc + v, 0)) // [3, 30, 300] without从数组中排除给定值。 使用 Array.filter() 创建一个不包括（使用!Array.includes()）所有给定值的数组。 1234const without = (arr, ...args) =&gt; arr.filter(v =&gt; !args.includes(v))// 示例 ↓without([2, 1, 2, 3], 1, 2) // [3] xProd通过从数组中创建每个可能的值，从提供的两个数组中创建一个新数组。 使用 array.prototype.reduce（）、array.prototype.map（）和 array.prototype.concat（）从两个数组的元素中生成每个可能的对，并将它们保存在一个数组中。 1234const xProd = (a, b) =&gt; a.reduce((acc, x) =&gt; acc.concat(b.map(y =&gt; [x, y])), [])// 示例 ↓xProd([1, 2], ['a', 'b']) // [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']] zip创建一组元素，根据原始数组中的位置进行分组。 使用 Math.max.apply() 获取参数中最长的数组。 创建一个长度为返回值的数组，并使用 Array.from() 和 map-function 来创建一个分组元素数组。 如果参数数组的长度不同，则在未找到值的情况下使用 undefined 。 12345678910const zip = (...arrays) =&gt; &#123; const maxLength = Math.max(...arrays.map(x =&gt; x.length)) return Array.from(&#123; length: maxLength &#125;).map((_, i) =&gt; &#123; return Array.from(&#123; length: arrays.length &#125;, (_, k) =&gt; arrays[k][i]) &#125;)&#125;// 示例 ↓zip(['a', 'b'], [1, 2], [true, false]) // [['a', 1, true], ['b', 2, false]]zip(['a'], [1, 2], [true, false]) // [['a', 1, true], [undefined, 2, false]] zipObject给定一个有效的属性标识符数组和一个值的数组，返回一个将属性关联到值的对象。 由于一个对象可以有未定义的值，但不存在未定义的属性，该属性数组用于使用 Array.reduce() 来决定结果对象的结构。 123456const zipObject = (props, values) =&gt; props.reduce((obj, prop, index) =&gt; ((obj[prop] = values[index]), obj), &#123;&#125;)// 示例 ↓zipObject(['a', 'b', 'c'], [1, 2]) // &#123;a: 1, b: 2, c: undefined&#125;zipObject(['a', 'b'], [1, 2, 3]) // &#123;a: 1, b: 2&#125; zipWith创建一个元素数组，根据原始数组中的位置进行分组，并使用函数作为最后一个值来指定组合值的方式。 检查提供的最后一个参数是否为函数。使用 math.max（）获取参数中最长的数组。创建一个以该长度作为返回值的数组，并使用带有 map 函数的 array.from（）创建一个分组元素数组。如果参数数组的长度不同，则在找不到值的情况下使用 UNDEFINED。使用每个组（…组）的元素调用函数。 1234567891011121314151617const zipWith = (...array) =&gt; &#123; const fn = typeof array[array.length - 1] === 'function' ? array.pop() : undefined return Array.from(&#123; length: Math.max(...array.map(a =&gt; a.length)) &#125;, (_, i) =&gt; fn ? fn(...array.map(a =&gt; a[i])) : array.map(a =&gt; a[i]) )&#125;// 示例 ↓zipWith([1, 2], [10, 20], [100, 200], (a, b, c) =&gt; a + b + c) // [111,222]zipWith( [1, 2, 3], [10, 20], [100, 200], (a, b, c) =&gt; (a != null ? a : 'a') + (b != null ? b : 'b') + (c != null ? c : 'c')) // [111, 222, '3bc'] P- Array 篇 Array 篇 all allEqual any arrayToCSV bifurcate bifurcateBy chunk compact countBy countOccurrences deepFlatten difference differenceBy differenceWith drop dropRight dropRightWhile dropWhile everyNth filterFalsy filterNonUnique filterNonUniqueBy findLast findLastIndex flatten forEachRight groupBy head indexOfAll initial initialize2DArray initializeArrayWithRange initializeArrayWithRangeRight initializeArrayWithValues initializeNDArray intersection intersectionBy intersectionWith isSorted join JSONtoCSV last longestItem mapObject maxN minN none nthElement offset partition permutations pull pullAtIndex pullAtValue pullBy reducedFilter reduceSuccessive reduceWhich reject remove sample sampleSize shank shuffle similarity sortedIndex sortedIndexBy sortedLastIndex sortedLastIndexBy symmetricDifference symmetricDifferenceBy symmetricDifferenceWith tail take takeRight takeRightWhile takeWhile toHash union unionBy unionWith uniqueElements uniqueElementsBy uniqueElementsByRight uniqueSymmetricDifference unzip unzipWith without xProd zip zipObject zipWith]]></content>
      <categories>
        <category>30-seconds-of-code</category>
      </categories>
      <tags>
        <tag>ECMAScript6+</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你需要学习的 Iterator和for...of循环]]></title>
    <url>%2F2019%2F01%2F02%2FIterator%2F</url>
    <content type="text"><![CDATA[Iterator 函数© Chirenmeng 一、理解 Iterator(遍历器)JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了Map和Set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是 Map，Map 的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。 遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。 Iterator 的作用有三个： 为各种数据结构，提供一个统一的、简便的访问接口 使得数据结构的成员能够按某种次序排列 ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费 Iterator 的遍历过程是这样的。 （1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 （2）第一次调用指针对象的 next 方法，可以将指针指向数据结构的第一个成员。 （3）第二次调用指针对象的 next 方法，指针就指向数据结构的第二个成员。 （4）不断调用指针对象的 next 方法，直到它指向数据结构的结束位置。 每一次调用 next 方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含 value 和 done 两个属性的对象。其中，value 属性是当前成员的值，done 属性是一个布尔值，表示遍历是否结束。 下面是一个模拟 next 方法返回值的例子: 123456789101112131415var it = makeIterator(['a', 'b'])it.next() // &#123; value: "a", done: false &#125;it.next() // &#123; value: "b", done: false &#125;it.next() // &#123; value: undefined, done: true &#125;function makeIterator(array) &#123; var nextIndex = 0 return &#123; next: function() &#123; return nextIndex &lt; array.length ? &#123; value: array[nextIndex++], done: false &#125; : &#123; value: undefined, done: true &#125; &#125; &#125;&#125; 上面代码定义了一个 makeIterator 函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组[‘a’, ‘b’]执行这个函数，就会返回该数组的遍历器对象（即指针对象）it。 指针对象的 next 方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用 next 方法，指针就会指向数组的下一个成员。第一次调用，指向 a；第二次调用，指向 b。 next 方法返回一个对象，表示当前数据成员的信息。这个对象具有 value 和 done 两个属性，value 属性返回当前位置的成员，done 属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用 next 方法。 总之，调用指针对象的 next 方法，就可以遍历事先给定的数据结构。 在 ES6 中，有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被 for…of 循环遍历，有些就不行（比如对象）。原因在于，这些数据结构原生部署了 Symbol.iterator 属性，另外一些数据结构没有。凡是部署了 Symbol.iterator 属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。 二、数据结构的默认 Iterator 接口Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即 for…of 循环。当使用 for…of 循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。 ES6 规定，默认的 Iterator 接口部署在数据结构的 Symbol.iterator 属性，或者说，一个数据结构只要具有 Symbol.iterator 属性，就可以认为是“可遍历的”（iterable）。调用 Symbol.iterator 方法，就会得到当前数据结构默认的遍历器生成函数。Symbol.iterator 本身是一个表达式，返回 Symbol 对象的 iterator 属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内。 在 ES6 中，有三类数据结构原生具备 Iterator 接口：数组、某些类似数组的对象、Set 和 Map 结构。 1234567let arr = ['a', 'b', 'c']let iter = arr[Symbol.iterator]()iter.next() // &#123; value: 'a', done: false &#125;iter.next() // &#123; value: 'b', done: false &#125;iter.next() // &#123; value: 'c', done: false &#125;iter.next() // &#123; value: undefined, done: true &#125; 上面代码中，变量 arr 是一个数组，原生就具有遍历器接口，部署在 arr 的 Symbol.iterator 属性上面。所以，调用这个属性，就得到遍历器对象。 上面提到，原生就部署 Iterator 接口的数据结构有三类，对于这三类数据结构，不用自己写遍历器生成函数，for…of 循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 Iterator 接口，都需要自己在 Symbol.iterator 属性上面部署，这样才会被 for…of 循环遍历。 对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。 一个对象如果要有可被 for…of 循环调用的 Iterator 接口，就必须在 Symbol.iterator 的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。 12345678910111213141516171819202122232425262728class RangeIterator &#123; constructor(start, stop) &#123; this.value = start this.stop = stop &#125; [Symbol.iterator]() &#123; return this &#125; next() &#123; var value = this.value if (value &lt; this.stop) &#123; this.value++ return &#123; done: false, value: value &#125; &#125; else &#123; return &#123; done: true, value: undefined &#125; &#125; &#125;&#125;function range(start, stop) &#123; return new RangeIterator(start, stop)&#125;for (var value of range(0, 3)) &#123; console.log(value) // 0 , 1 , 2&#125; 上面代码是一个类部署 Iterator 接口的写法。Symbol.iterator 属性对应一个函数，执行后返回当前对象的遍历器对象。 下面是通过遍历器实现指针结构的例子: 123456789101112131415161718192021222324252627282930313233343536373839function Obj(value) &#123; this.value = value this.next = null&#125;Obj.prototype[Symbol.iterator] = function() &#123; var iterator = &#123; next: next &#125; var current = this function next() &#123; if (current) &#123; var value = current.value current = current.next return &#123; done: false, value: value &#125; &#125; else &#123; return &#123; done: true &#125; &#125; &#125; return iterator&#125;var one = new Obj(1)var two = new Obj(2)var three = new Obj(3)one.next = twotwo.next = threefor (var i of one) &#123; console.log(i) // 1 , 2 , 3&#125; 上面代码首先在构造函数的原型链上部署 Symbol.iterator 方法，调用该方法会返回遍历器对象 iterator，调用该对象的 next 方法，在返回一个值的同时，自动将内部指针移到下一个实例。 为对象添加 Iterator 接口的例子： 12345678910111213141516171819let obj = &#123; data: ['hello', 'world'], [Symbol.iterator]() &#123; const self = this let index = 0 return &#123; next() &#123; if (index &lt; self.data.length) &#123; return &#123; value: self.data[index++], done: false &#125; &#125; else &#123; return &#123; value: undefined, done: true &#125; &#125; &#125; &#125; &#125;&#125; 对于类似数组的对象（存在数值键名和 length 属性），部署 Iterator 接口，有一个简便方法，就是 Symbol.iterator 方法直接引用数组的 Iterator 接口。 1234567891011121314151617NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator]// 或者NodeList.prototype[Symbol.iterator] = [][Symbol.iterator][...document.querySelectorAll('div')] // 可以执行了// 示例 ↓let iterable = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator]&#125;for (let item of iterable) &#123; console.log(item); // a , b , c&#125; 但是请记住，这个方法仅仅适用于类数组对象，上面的也可以直接用 Array.from(iterable)转换成数组来遍历，例如： 123456789let arrayLike = &#123; length: 2, 0: 'a', 1: 'b'3&#125;for (let x of Array.from(arrayLike)) &#123; console.log(x) // a , b&#125; 三、调用 Iterator 接口的场合解构赋值对数组和 Set 结构进行解构赋值时，会默认调用 Symbol.iterator 方法。 12345678910let set = new Set() .add('a') .add('b') .add('c')let [x, y] = set// x='a'; y='b'let [first, ...rest] = set// first='a'; rest=['b','c'] 扩展运算符扩展运算符（…）也会调用默认的 iterator 接口。 12345678// 例一var str = 'hello'[...str] // ['h','e','l','l','o']// 例二let arr = ['b', 'c']['a', ...arr, 'd']// ['a', 'b', 'c', 'd'] 也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。 1let arr = [...iterable] yield*yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。 1234567891011121314let generator = function*() &#123; yield 1 yield* [2, 3, 4] yield 5&#125;var iterator = generator()iterator.next() // &#123; value: 1, done: false &#125;iterator.next() // &#123; value: 2, done: false &#125;iterator.next() // &#123; value: 3, done: false &#125;iterator.next() // &#123; value: 4, done: false &#125;iterator.next() // &#123; value: 5, done: false &#125;iterator.next() // &#123; value: undefined, done: true &#125; 其他场合由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。 for…of Array.from() Map(), Set(), WeakMap(), WeakSet()（比如 new Map([[‘a’,1],[‘b’,2]])） Promise.all() Promise.race() 四、字符串的 Iterator 接口字符串是一个类似数组的对象，也原生具有 Iterator 接口。 123456789var someString = 'hi'typeof someString[Symbol.iterator]// "function"var iterator = someString[Symbol.iterator]()iterator.next() // &#123; value: "h", done: false &#125;iterator.next() // &#123; value: "i", done: false &#125;iterator.next() // &#123; value: undefined, done: true &#125; 上面代码中，调用 Symbol.iterator 方法返回一个遍历器对象，在这个遍历器上可以调用 next 方法，实现对于字符串的遍历。 可以覆盖原生的 Symbol.iterator 方法，达到修改遍历器行为的目的。 1234567891011121314151617181920var str = new String('hi')[...str] // ["h", "i"]str[Symbol.iterator] = function() &#123; return &#123; next: function() &#123; if (this._first) &#123; this._first = false return &#123; value: 'bye', done: false &#125; &#125; else &#123; return &#123; done: true &#125; &#125; &#125;, _first: true &#125;&#125;[...str] // ["bye"]str // "hi" 上面代码中，字符串 str 的 Symbol.iterator 方法被修改了，所以扩展运算符（…）返回的值变成了 bye，而字符串本身还是 hi。 五、Iterator 接口与 Generator 函数Symbol.iterator 方法的最简单实现 1234567891011121314151617181920212223var myIterable = &#123;&#125;myIterable[Symbol.iterator] = function*() &#123; yield 1 yield 2 yield 3&#125;[...myIterable] // [1, 2, 3]// 或者采用下面的简洁写法let obj = &#123; *[Symbol.iterator]() &#123; yield 'hello' yield 'world' &#125;&#125;for (let x of obj) &#123; console.log(x)&#125;// hello// world 上面代码中，Symbol.iterator 方法几乎不用部署任何代码，只要用 yield 命令给出每一步的返回值即可。 六、遍历器对象的 return()，throw()遍历器对象除了具有 next 方法，还可以具有 return 方法和 throw 方法。如果你自己写遍历器对象生成函数，那么 next 方法是必须部署的，return 方法和 throw 方法是否部署是可选的。 return 方法的使用场合是，如果 for…of 循环提前退出（通常是因为出错，或者有 break 语句或 continue 语句），就会调用 return 方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署 return 方法。 12345678910111213141516171819function readLinesSync(file) &#123; return &#123; next() &#123; if (file.isAtEndOfFile()) &#123; file.close() return &#123; done: true &#125; &#125; &#125;, return() &#123; file.close() return &#123; done: true &#125; &#125; &#125;&#125;for (let line of readLinesSync(fileName)) &#123; console.log(line) break&#125; 上面代码中，函数 readLinesSync 接受一个文件对象作为参数，返回一个遍历器对象，其中除了 next 方法，还部署了 return 方法。下面，我们让文件的遍历提前返回，这样就会触发执行 return 方法。 注意，return 方法必须返回一个对象，这是 Generator 规格决定的。 七、for…of 循环ES6 借鉴 C++、Java、C#和 Python 语言，引入了 for…of 循环，作为遍历所有数据结构的统一的方法。一个数据结构只要部署了 Symbol.iterator 属性，就被视为具有 iterator 接口，就可以用 for…of 循环遍历它的成员。也就是说，for…of 循环内部调用的是数据结构的 Symbol.iterator 方法。 for…of 循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如 arguments 对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。 数组数组原生具备 iterator 接口，for…of 循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。 12345678910const arr = ['red', 'green', 'blue']let iterator = arr[Symbol.iterator]()for (let v of arr) &#123; console.log(v) // red green blue&#125;for (let v of iterator) &#123; console.log(v) // red green blue&#125; 上面代码的 for…of 循环的两种写法是等价的。 for…of 循环可以代替数组实例的 forEach 方法。 123456const arr = ['red', 'green', 'blue']arr.forEach(function(element, index) &#123; console.log(element) // red green blue console.log(index) // 0 1 2&#125;) JavaScript 原有的 for…in 循环，只能获得对象的键名，不能直接获取键值。ES6 提供 for…of 循环，允许遍历获得键值。 123456789var arr = ['a', 'b', 'c', 'd']for (let a in arr) &#123; console.log(a) // 0 1 2 3&#125;for (let a of arr) &#123; console.log(a) // a b c d&#125; 上面代码表明，for…in 循环读取键名，for…of 循环读取键值。如果要通过 for…of 循环，获取数组的索引，可以借助数组实例的 entries 方法和 keys 方法。 for…of 循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟 for…in 循环也不一样。 12345678910let arr = [3, 5, 7]arr.foo = 'hello'for (let i in arr) &#123; console.log(i) // "0", "1", "2", "foo"&#125;for (let i of arr) &#123; console.log(i) // "3", "5", "7"&#125; 上面代码中，for…of 循环不会返回数组 arr 的 foo 属性。 Set 和 Map 结构Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用 for…of 循环。 123456789101112131415161718var engines = new Set(['Gecko', 'Trident', 'Webkit', 'Webkit'])for (var e of engines) &#123; console.log(e)&#125;// Gecko// Trident// Webkitvar es6 = new Map()es6.set('edition', 6)es6.set('committee', 'TC39')es6.set('standard', 'ECMA-262')for (var [name, value] of es6) &#123; console.log(name + ': ' + value)&#125;// edition: 6// committee: TC39// standard: ECMA-262 上面代码演示了如何遍历 Set 结构和 Map 结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。 123456789101112let map = new Map().set('a', 1).set('b', 2)for (let pair of map) &#123; console.log(pair)&#125;// ['a', 1]// ['b', 2]for (let [key, value] of map) &#123; console.log(key + ' : ' + value)&#125;// a : 1// b : 2 计算生成的数据结构有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。 entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 iterator 接口，默认就是调用 entries 方法。 keys() 返回一个遍历器对象，用来遍历所有的键名。 values() 返回一个遍历器对象，用来遍历所有的键值。 1234567let arr = ['a', 'b', 'c']for (let pair of arr.entries()) &#123; console.log(pair)&#125;// [0, 'a']// [1, 'b']// [2, 'c'] 类似数组的对象类似数组的对象包括好几类。下面是 for…of 循环用于字符串、DOM NodeList 对象、arguments 对象的例子。 1234567891011121314151617181920212223// 字符串let str = 'hello'for (let s of str) &#123; console.log(s) // h e l l o&#125;// DOM NodeList对象let paras = document.querySelectorAll('p')for (let p of paras) &#123; p.classList.add('test')&#125;// arguments对象function printArgs() &#123; for (let x of arguments) &#123; console.log(x) &#125;&#125;printArgs('a', 'b')// 'a'// 'b' 对于字符串来说，for…of 循环还有一个特点，就是会正确识别 32 位 UTF-16 字符。 12345for (let x of 'a\uD83D\uDC0A') &#123; console.log(x)&#125;// 'a'// '\uD83D\uDC0A' 并不是所有类似数组的对象都具有 iterator 接口，一个简便的解决方法，就是使用 Array.from 方法将其转为数组。 1234567891011let arrayLike = &#123; length: 2, 0: 'a', 1: 'b' &#125;// 报错for (let x of arrayLike) &#123; console.log(x)&#125;// 正确for (let x of Array.from(arrayLike)) &#123; console.log(x)&#125; 对象对于普通的对象，for…of 结构不能直接使用，会报错，必须部署了 iterator 接口后才能使用。但是，这样情况下，for…in 循环依然可以用来遍历键名。 1234567891011121314151617var es6 = &#123; edition: 6, committee: 'TC39', standard: 'ECMA-262'&#125;for (e in es6) &#123; console.log(e)&#125;// edition// committee// standardfor (e of es6) &#123; console.log(e)&#125;// TypeError: es6 is not iterable 上面代码表示，对于普通的对象，for…in 循环可以遍历键名，for…of 循环会报错。 一种解决方法是，使用 Object.keys 方法将对象的键名生成一个数组，然后遍历这个数组。 123for (var key of Object.keys(someObject)) &#123; console.log(key + ': ' + someObject[key])&#125; 在对象上部署 iterator 接口的代码，一个方便的方法是将数组的 Symbol.iterator 属性，直接赋值给其他对象的 Symbol.iterator 属性。比如，想要让 for…of 环遍历 jQuery 对象，只要加上下面这一行就可以了。 1jQuery.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator] 另一个方法是使用 Generator 函数将对象重新包装一下。 123456789101112function* entries(obj) &#123; for (let key of Object.keys(obj)) &#123; yield [key, obj[key]] &#125;&#125;for (let [key, value] of entries(obj)) &#123; console.log(key, '-&gt;', value)&#125;// a -&gt; 1// b -&gt; 2// c -&gt; 3 与其他遍历语法的比较以数组为例，JavaScript 提供多种遍历语法。最原始的写法就是 for 循环。 123for (var index = 0; index &lt; myArray.length; index++) &#123; console.log(myArray[index])&#125; 这种写法比较麻烦，因此数组提供内置的 forEach 方法。 123myArray.forEach(function(value) &#123; console.log(value)&#125;) 这种写法的问题在于，无法中途跳出 forEach 循环，break 命令或 return 命令都不能奏效。 for…in 循环可以遍历数组的键名。 123for (var index in myArray) &#123; console.log(myArray[index])&#125; for…in 循环有几个缺点。 数组的键名是数字，但是 for…in 循环是以字符串作为键名“0”、“1”、“2”等等。 for…in 循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。 某些情况下，for…in 循环会以任意顺序遍历键名。 总之，for…in 循环主要是为遍历对象而设计的，不适用于遍历数组。 for…of 循环相比上面几种做法，有一些显著的优点。 123for (let value of myArray) &#123; console.log(value)&#125; 有着同 for…in 一样的简洁语法，但是没有 for…in 那些缺点。 不同用于 forEach 方法，它可以与 break、continue 和 return 配合使用。 提供了遍历所有数据结构的统一操作接口。 下面是一个使用 break 语句，跳出 for…of 循环的例子。 1234for (var n of fibonacci) &#123; if (n &gt; 1000) break console.log(n)&#125; 上面的例子，会输出斐波纳契数列小于等于 1000 的项。如果当前项大于 1000，就会使用 break 语句跳出 for…of 循环。 Iterator 函数 一、理解 Iterator(遍历器) 二、数据结构的默认 Iterator 接口 三、调用 Iterator 接口的场合 解构赋值 扩展运算符 yield* 其他场合 四、字符串的 Iterator 接口 五、Iterator 接口与 Generator 函数 六、遍历器对象的 return()，throw() 七、for…of 循环 数组 Set 和 Map 结构 计算生成的数据结构 类似数组的对象 对象 与其他遍历语法的比较]]></content>
      <categories>
        <category>ES6+</category>
      </categories>
      <tags>
        <tag>ECMAScript6+</tag>
        <tag>Iterator</tag>
        <tag>for...of循环</tag>
        <tag>遍历器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[30秒学习JavaScript代码段(Adapter篇)]]></title>
    <url>%2F2018%2F12%2F29%2F30-seconds-of-code%2F</url>
    <content type="text"><![CDATA[Adapter 篇© Chirenmeng 本文译自：30-seconds-of-code ary创建一个接受 n 个参数的函数，忽略大于 n 个的其余参数。 调用传入的函数 fn 并传入给定的 n 个参数。 参数通过 Array.slice(0,n) 截取，并使用(…)解构。 12345678const ary = (fn, n) =&gt; (...args) =&gt; fn(...args.slice(0, n))// 示例 ↓const firstTwoMax = ary(Math.max, 2)var maxNum = [[2, 6, 'a'], [8, 4, 6], [10]].map(x =&gt; firstTwoMax(...x))console.log(maxNum) // [6, 8, 10] call接受一个键值和一个 set 作为参数，在给定上下文时调用它们。主要用于组合。 使用闭包在调用的时候存储键值和参数。 1234567891011const call = (key, ...args) =&gt; context =&gt; context[key](...args)// 示例 ↓Promise.resolve([1, 2, 3]) .then(call('map', x =&gt; 2 * x)) .then(console.log) // [ 2, 4, 6 ]const map = call.bind(null, 'map')Promise.resolve([1, 2, 3]) .then(map(x =&gt; 2 * x)) .then(console.log) // [ 2, 4, 6 ] collectInto将接受数组的函数变为接受变量的函数。 给定一个函数，返回一个闭包，将所有输入收集到一个接受函数的数组中。 12345678const collectInto = fn =&gt; (...args) =&gt; fn(args)// 示例 ↓const Pall = collectInto(Promise.all.bind(Promise))let p1 = Promise.resolve(1)let p2 = Promise.resolve(2)let p3 = new Promise(resolve =&gt; setTimeout(resolve, 2000, 3))Pall(p1, p2, p3).then(console.log) // [1, 2, 3] (after about 2 seconds) flipflip 接受函数作为参数，然后将函数第一个参数赋给最后一个参数。 返回一个可以接受变量输入的闭包，并展开剩余参数，之后将其变为第一个参数。 12345678910const flip = fn =&gt; (first, ...rest) =&gt; fn(...rest, first)// 示例 ↓let a = &#123; name: 'John Smith' &#125;let b = &#123;&#125;const mergeFrom = flip(Object.assign)let mergePerson = mergeFrom.bind(null, a)mergePerson(b) // == bb = &#123;&#125;Object.assign(b, a) // == b over创建一个函数，用它接收到的参数调用每个提供的函数，并返回结果。 使用 Array.map（）和 Function.apply（） 将给定的参数应用到每个函数。 12345const over = (...fns) =&gt; (...args) =&gt; fns.map(fn =&gt; fn.apply(null, args))// 示例 ↓const minMax = over(Math.min, Math.max)minMax(1, 2, 3, 4, 5) // [1,5] overArgs给定一个函数，通过指定函数转变其参数后再调用。 使用 Array.prototype.map()与扩展运算符(…)将转换后的参数传递给 fn。 12345678const overArgs = (fn, transforms) =&gt; (...args) =&gt; fn(...args.map((val, i) =&gt; transforms[i](val)))// 示例 ↓const square = n =&gt; n * nconst double = n =&gt; n * 2const fn = overArgs((x, y) =&gt; [x, y], [square, double])fn(9, 3) // [81, 6] pipeAsyncFunctions从左到右的执行异步函数组合。 使用 Array.reduce（）与展开操作符（…），从左到右使用 Promise.then（）执行函数组合。 这些函数可以返回：简单值，Promise 的组合或者定义为通过 await 返回的异步。 所有函数必须是一元函数。 1234567891011121314const pipeAsyncFunctions = (...fns) =&gt; arg =&gt; fns.reduce((p, f) =&gt; p.then(f), Promise.resolve(arg))// 示例 ↓const sum = pipeAsyncFunctions( x =&gt; x + 1, x =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve(x + 2), 1000)), x =&gt; x + 3, async x =&gt; (await x) + 4)var fn = async () =&gt; &#123; console.log(await sum(5))&#125;fn() // 15 (after one second) pipeFunctions执行从左到右的函数组合。 使用 Array.reduce() 与展开操作符 (…) 来执行从左到右的函数组合。第一个(最左边的)函数可以接受一个或多个参数；其余的函数必须是一元函数。 12345678const pipeFunctions = (...fns) =&gt; fns.reduce((f, g) =&gt; (...args) =&gt; g(f(...args)))// 示例 ↓const add5 = x =&gt; x + 5const multiply = (x, y) =&gt; x * yconst multiplyAndAdd5 = pipeFunctions(multiply, add5)multiplyAndAdd5(5, 2) // 15 promisify转换异步函数并返回 promise。 使用柯里化返回一个函数，这个函数返回一个调用原始函数的 Promise 。 使用 …rest 运算符传入所有参数。 在 Node 8+，你可以使用 util.promify 12345678const promisify = func =&gt; (...args) =&gt; new Promise((resolve, reject) =&gt; func(...args, (err, result) =&gt; (err ? reject(err) : resolve(result))) )// 示例 ↓const delay = promisify((d, cb) =&gt; setTimeout(cb, d))delay(2000).then(() =&gt; console.log('Hi!')) // // Promise resolves after 2s rearg创建一个函数调用给定的函数，给定的函数参数按照指定的索引排列。 基于 indexes 使用 Array.reduce() 和 Array.indexOf() 重排参数，使用展开操作符 (…) 向给定函数传参。 12345678910const rearg = (fn, indexes) =&gt; (...args) =&gt; fn(...indexes.map(i =&gt; args[i]))// 示例 ↓var rearged = rearg( function(a, b, c) &#123; return [a, b, c] &#125;, [2, 0, 1])rearged('b', 'c', 'a') // ['a', 'b', 'c'] spreadOver接受一个函数并返回一个闭包，该闭包接受一组参数并映射到函数的变量。 使用闭包和扩展运算符(…)将数组映射为函数的变量。 12345const spreadOver = fn =&gt; argsArr =&gt; fn(...argsArr)// 示例 ↓const arrayMax = spreadOver(Math.max)arrayMax([1, 2, 3]) // 3 unary创建一个最多接受一个参数的函数，忽略任何附加参数。 调用给定函数，只传入第一个参数。 12345const unary = fn =&gt; val =&gt; fn(val)// 示例 ↓var intNum = ['6', '8', '10'].map(unary(parseInt))console.log(intNum) // [6, 8, 10] Adapter 篇 ary call collectInto flip over overArgs pipeAsyncFunctions pipeFunctions promisify rearg spreadOver unary]]></content>
      <categories>
        <category>30-seconds-of-code</category>
      </categories>
      <tags>
        <tag>ECMAScript6+</tag>
        <tag>Adapter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你需要学习的 Async函数]]></title>
    <url>%2F2018%2F12%2F28%2FAsync%2F</url>
    <content type="text"><![CDATA[Async 函数© Chirenmeng 一、Async/awaitES7 提供了 async 函数，使得异步操作变得更加方便。async 函数是什么？ 一句话，async 函数就是 Generator 函数的语法糖。 Async functions 这个函数总是返回一个 promise，如果代码中有 return &lt;非 promise&gt;语句，JavaScript 会自动把返回的这个 value 值包装成 promise 的 resolved 值。当 async 函数抛出异常时，promise 的 reject 方法也会传递这个异常值。 123456async function f() &#123; return 1&#125;f().then(e =&gt; &#123; console.log(e) // 1&#125;) Await async 函数中可能会有 await 表达式，这会使 async 函数暂停执行，等待 Promise 的结果出来，然后恢复 async 函数的执行并返回解析值（resolved）。 注意：await 只能在 async 函数内部使用 12345678async function f() &#123; let promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve('done!'), 1000) &#125;) let result = await promise // 直到promise返回一个resolve值 console.log(result) // 'done!'&#125;f() 函数执行到 await promise 行会暂停，当 promise 处理完成后重新恢复运行， resolve 的值成了最终的 result，所以上面的代码会在 1s 后输出’done!’。 我们强调一下：await 字面上使得 JavaScript 等待，直到 promise 处理完成，然后将结果继续下去。 但这并不会花费任何的 cpu 资源，因为引擎能够同时做其他工作：执行其他脚本，处理事件等等。 二、错误处理12345678910111213141516171819202122async function f() &#123; try &#123; let response = await fetch('/no-user-here') let user = await response.json() &#125; catch(err) &#123; // 在fetch和response.json中都能捕获错误 console.log(err) &#125;&#125;f()-----------------分割线-----------------//如果我们不使用try-catch，然后async函数f()的调用产生的promise变成reject状态的话，我们可以添加.catch去处理它。async function f() &#123; let response = await fetch('http://no-such-url')&#125;f().catch (e =&gt; &#123; console.log(e) // TypeError: failed to fetch&#125;) async 函数是非常新的语法功能，新到都不属于 ES6，而是属于 ES7。目前，它仍处于提案阶段，但是转码器 Babel 和 regenerator 都已经支持，转码后就能使用。 Async 函数的多种使用形式1234567891011// 函数声明async function foo() &#123;&#125;// 函数表达式const foo = async function() &#123;&#125;// 对象的方法let obj = &#123; async foo() &#123;&#125; &#125;// 箭头函数const foo = async () =&gt; &#123;&#125; Async 与 Promise、Generator 的比较我们通过一个例子，来看 Async 函数与 Promise、Generator 函数的区别。 假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function chainAnimationsPromise(elem, animations) &#123; // Promise的写法 // 变量ret用来保存上一个动画的返回值 var ret = null // 新建一个空的Promise var p = Promise.resolve() // 使用then方法，添加所有动画 for (var anim of animations) &#123; p = p.then(function(val) &#123; ret = val return anim(elem) &#125;) &#125; // 返回一个部署了错误捕捉机制的Promise return p .catch(function(e) &#123; /* 忽略错误，继续执行 */ &#125;) .then(function() &#123; return ret &#125;)&#125;function chainAnimationsGenerator(elem, animations) &#123; // Generator的写法 return spawn(function*() &#123; var ret = null try &#123; for (var anim of animations) &#123; ret = yield anim(elem) &#125; &#125; catch (e) &#123; /* 忽略错误，继续执行 */ &#125; return ret &#125;)&#125;async function chainAnimationsAsync(elem, animations) &#123; // Async的写法 var ret = null try &#123; for (var anim of animations) &#123; ret = await anim(elem) &#125; &#125; catch (e) &#123; /* 忽略错误，继续执行 */ &#125; return ret&#125; 可以看到 Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 Generator 写法，自动执行器需要用户自己提供。 上一段代码的 spawn 函数就是自动执行器,下面给出 spawn 函数的实现: 123456789101112131415161718192021222324252627282930function spawn(genF) &#123; return new Promise(function(resolve, reject) &#123; var gen = genF() function step(nextF) &#123; try &#123; var next = nextF() &#125; catch (e) &#123; return reject(e) &#125; if (next.done) &#123; return resolve(next.value) &#125; Promise.resolve(next.value).then( function(v) &#123; step(function() &#123; return gen.next(v) &#125;) &#125;, function(e) &#123; step(function() &#123; return gen.throw(e) &#125;) &#125; ) &#125; step(function() &#123; return gen.next(undefined) &#125;) &#125;)&#125; Async 函数 一、Async/await Async functions Await 二、错误处理 Async 函数的多种使用形式 Async 与 Promise、Generator 的比较]]></content>
      <categories>
        <category>ES6+</category>
      </categories>
      <tags>
        <tag>ECMAScript6+</tag>
        <tag>Async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你需要学习的 Generator函数]]></title>
    <url>%2F2018%2F12%2F26%2FGenerator%2F</url>
    <content type="text"><![CDATA[Generator 函数© Chirenmeng 一、理解 Generator(生成器)生成器对象是由一个 generator function 返回的,并且它符合可迭代协议和迭代器协议。 形式上，Generator 函数是一个普通函数，但是有两个特征。 一是，function 关键字与函数名之间有一个星号； 二是，函数体内部使用 yield 语句，定义不同的内部状态（yield 语句在英语里的意思就是“产出”）。 我们来看一个简单的小例子： 12345678910111213141516171819function* gen() &#123; yield '1' yield '2' return '3'&#125;var g = gen()var a = g.next()console.log(a) // &#123; value: '1', done: false &#125;var b = g.next()console.log(b) // &#123; value: '2', done: false &#125;var c = g.next()console.log(c) // &#123; value: '3', done: true &#125;var d = g.next()console.log(d) // &#123; value: undefined, done: true &#125; 总结： 调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的 next 方法，就会返回一个有着 value 和 done 两个属性的对象。 value 属性表示当前的内部状态的值，是 yield 语句后面那个表达式的值；done 属性是一个布尔值，表示是否遍历结束。 二、yield由于 Generator 函数返回的遍历器对象，只有调用 next 方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield 语句就是暂停标志。 遍历器对象的 next 方法的运行逻辑如下。 遇到 yield 语句，就暂停执行后面的操作，并将紧跟在 yield 后面的那个表达式的值，作为返回的对象的 value 属性值。 下一次调用 next 方法时，再继续往下执行，直到遇到下一个 yield 语句。 如果没有再遇到新的 yield 语句，就一直运行到函数结束，直到 return 语句为止，并将 return 语句后面的表达式的值，作为返回的对象的 value 属性值。 如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined。 需要注意的是，yield 语句后面的表达式，只有当调用 next 方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。 yield* yield 的返回值是当作一个元素 yield* 的返回值是一个 iterator，会依次返回这个 iterator 中的每个元素 123456789101112131415function* sub() &#123; for (let i = 65; i &lt; 70; i++) &#123; yield String.fromCharCode(i) &#125;&#125;function* main() &#123; yield sub() // 返回的是 sub() 的结果, Object [Generator] &#123;&#125; yield '---------' yield* sub() // 依次返回 sub() 结果的的每一项&#125;for (var v of main()) &#123; console.log(v)&#125; 注意事项 yield 语句不能用在普通函数中，否则会报错。 12345678910111213141516171819202122232425262728293031323334353637var arr = [1, [[2, 3], 4], [5, 6]];var flat = function* (a) &#123; a.forEach(function (item) &#123; // forEach方法的参数是一个普通函数 if (typeof item !== 'number') &#123; yield* flat(item); &#125; else &#123; yield item; &#125; &#125;&#125;;for (var f of flat(arr))&#123; console.log(f); // SyntaxError: Unexpected number&#125;————————————————————————————————修改方法————————————————————————————————var arr = [1, [[2, 3], 4], [5, 6]];var flat = function* (a) &#123; var length = a.length; for (var i = 0; i &lt; length; i++) &#123; // 改用for循环 var item = a[i]; if (typeof item !== 'number') &#123; yield* flat(item); &#125; else &#123; yield item; &#125; &#125;&#125;;for (var f of flat(arr)) &#123; console.log(f);&#125;// 1, 2, 3, 4, 5, 6 yield 语句如果用在一个表达式之中，必须放在圆括号里面 12345console.log('Hello' + yield); // SyntaxErrorconsole.log('Hello' + yield 123); // SyntaxErrorconsole.log('Hello' + (yield)); // OKconsole.log('Hello' + (yield 123)); // OK yield 语句用作函数参数或赋值表达式的右边，可以不加括号。 123foo(yield 'a', yield 'b'); // OKlet input = yield; // OK 三、next 方法的参数yield 句本身没有返回值，或者说总是返回 undefined。 next 方法可以带一个参数，该参数就会被当作上一个 yield 语句的返回值。 1234567891011121314function* f() &#123; for (var i = 0; true; i++) &#123; var reset = yield i if (reset) &#123; i = -1 &#125; &#125;&#125;var g = f()g.next() // &#123; value: 0, done: false &#125;g.next() // &#123; value: 1, done: false &#125;g.next(true) // &#123; value: 0, done: false &#125; 上面代码先定义了一个可以无限运行的 Generator 函数 f，如果 next 方法没有参数，每次运行到 yield 语句，变量 reset 的值总是 undefined。当 next 方法带一个参数 true 时，当前的变量 reset 就被重置为这个参数（即 true），因此 i 会等于-1，下一轮循环就会从-1 开始递增。 这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过 next 方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。 四、配合使用 for…of 循环for…of 循环可以自动遍历 Generator 函数时生成的 Iterator 对象，且此时不再需要调用 next 方法。 12345678910111213function* foo() &#123; yield 1 yield 2 yield 3 yield 4 yield 5 return 6&#125;for (let v of foo()) &#123; console.log(v)&#125;// 1 2 3 4 5 注意：一旦 next 方法的返回对象的 done 属性为 true，for…of 循环就会中止，且不包含该返回对象，所以上面代码的 return 语句返回的 6，不包括在 for…of 循环之中。 利用 for…of 循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，无法使用 for…of 循环，通过 Generator 函数为它加上这个接口，就可以用了： 123456789101112131415161718192021222324252627282930313233343536373839function* objectEntries(obj) &#123; let propKeys = Reflect.ownKeys(obj); for (let propKey of propKeys) &#123; yield [propKey, obj[propKey]]; &#125;&#125;let jane = &#123; first: 'Jane', last: 'Doe' &#125;;for (let [key, value] of objectEntries(jane)) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe————————————————————————————————另一种写法————————————————————————————————// 上面代码中，对象jane原生不具备Iterator接口，无法用for...of遍历。// 这时，我们通过Generator函数objectEntries为它加上遍历器接口，就可以用for...of遍历了。// 加上遍历器接口的另一种写法是，将Generator函数加到对象的Symbol.iterator属性上面。function* objectEntries() &#123; let propKeys = Object.keys(this); for (let propKey of propKeys) &#123; yield [propKey, this[propKey]]; &#125;&#125;let jane = &#123; first: 'Jane', last: 'Doe' &#125;;jane[Symbol.iterator] = objectEntries;for (let [key, value] of jane) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe 除了 for…of 循环以外，扩展运算符（…）、解构赋值和 Array.from 方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。 123456789101112131415161718192021222324function* numbers() &#123; yield 1 yield 2 return 3 yield 4&#125;// 扩展运算符;[...numbers()] // [1, 2]// Array.form 方法Array.from(numbers()) // [1, 2]// 解构赋值let [x, y] = numbers()x // 1y // 2// for...of 循环for (let n of numbers()) &#123; console.log(n)&#125;// 1// 2 五、Generator 函数返回的遍历器对象的方法1. Generator.prototype.throw()Generator 函数返回的遍历器对象，都有一个 throw 方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。 12345678910111213141516171819202122var g = function*() &#123; try &#123; yield &#125; catch (e) &#123; console.log('内部捕获', e) // 注：此处代码运行结束有一个隐藏的return &#125;&#125;var i = g()i.next()try &#123; i.throw('a') var b = i.next('b') console.log(b) i.throw('c')&#125; catch (e) &#123; console.log('外部捕获', e)&#125;// 依次打印如下:// 内部捕获 a// &#123; value: undefined, done: true &#125;// 外部捕获 c 上面代码中，遍历器对象 i 连续抛出两个错误。第一个错误被 Generator 函数体内的 catch 语句捕获。i 第二次抛出错误，由于 Generator 函数内部的 catch 语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的 catch 语句捕获。 注意：throw 方法被捕获以后，会附带执行下一条 yield 语句。也就是说，会附带执行一次 next 方法。 1234567891011121314var gen = function* gen() &#123; try &#123; yield console.log('a') &#125; catch (e) &#123; // ... &#125; yield console.log('b') yield console.log('c')&#125;var g = gen()g.next() // ag.throw() // bg.next() // c 上面代码中，g.throw 方法被捕获以后，自动执行了一次 next 方法，所以会打印 b。另外，也可以看到，只要 Generator 函数内部部署了 try…catch 代码块，那么遍历器的 throw 方法抛出的错误，不影响下一次遍历。 需要注意的是，不要混淆遍历器对象的 throw 方法和全局的 throw 命令。 用 throw 命令抛出的，如：throw new Error(‘a’),只能被函数体外的 catch 语句捕获。 而 Generator 函数 throw 方法 抛出的错误，可以在函数体内捕获，也可以被函数体外的 catch 捕获。 123456789101112131415function* foo() &#123; var x = yield 3 var y = x.toUpperCase() yield y&#125;var it = foo()it.next() // &#123; value:3, done:false &#125;try &#123; it.next(42)&#125; catch (err) &#123; console.log(err)&#125; 上面代码中，第二个 next 方法向函数体内传入一个参数 42，数值是没有 toUpperCase 方法的，所以会抛出一个 TypeError 错误，被函数体外的 catch 捕获。 2. Generator.prototype.return()Generator 函数返回的遍历器对象，还有一个 return 方法，可以返回给定的值，并且终结遍历 Generator 函数。 1234567891011function* gen() &#123; yield 1 yield 2 yield 3&#125;var g = gen()g.next() // &#123; value: 1, done: false &#125;g.return('foo') // &#123; value: "foo", done: true &#125;g.next() // &#123; value: undefined, done: true &#125; 上面代码中，遍历器对象 g 调用 return 方法后，返回值的 value 属性就是 return 方法的参数 foo。并且，Generator 函数的遍历就终止了，返回值的 done 属性为 true，以后再调用 next 方法，done 属性总是返回 true。 如果 Generator 函数内部有 try…finally 代码块，那么 return 方法会推迟到 finally 代码块执行完再执行。 1234567891011121314151617function* numbers() &#123; yield 1 try &#123; yield 2 yield 3 &#125; finally &#123; yield 4 yield 5 &#125; yield 6&#125;var g = numbers()g.next() // &#123; done: false, value: 1 &#125;g.next() // &#123; done: false, value: 2 &#125;g.return(7) // &#123; done: false, value: 4 &#125;g.next() // &#123; done: false, value: 5 &#125;g.next() // &#123; done: true, value: 7 &#125; 上面代码中，调用 return 方法后，就开始执行 finally 代码块，然后等到 finally 代码块执行完，再执行 return 方法。 六、Generator 函数的 thisGenerator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的 prototype 对象上的方法。 12345678910function* g() &#123;&#125;g.prototype.hello = function() &#123; return 'hi!'&#125;let obj = g()obj instanceof g // trueobj.hello() // 'hi!' 上面代码表明，Generator 函数 g 返回的遍历器 obj，是 g 的实例，而且继承了 g.prototype。 但是，如果把 g 当作普通的构造函数，并不会生效，因为 g 返回的总是遍历器对象，而不是 this 对象。 123456function* g() &#123; this.a = 11&#125;let obj = g()obj.a // undefined 上面代码中，Generator 函数 g 在 this 对象上面添加了一个属性 a，但是 obj 对象拿不到这个属性。 那么，有没有办法让 Generator 函数返回一个正常的对象实例，既可以用 next 方法，又可以获得正常的 this？ 下面是一个变通方法。首先，生成一个空对象，使用 bind 方法绑定 Generator 函数内部的 this。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。 123456789101112131415function* F() &#123; this.a = 1 yield (this.b = 2) yield (this.c = 3)&#125;var obj = &#123;&#125;var f = F.call(obj)f.next() // Object &#123;value: 2, done: false&#125;f.next() // Object &#123;value: 3, done: false&#125;f.next() // Object &#123;value: undefined, done: true&#125;obj.a // 1obj.b // 2obj.c // 3 上面代码中，首先是 F 内部的 this 对象绑定 obj 对象，然后调用它，返回一个 Iterator 对象。这个对象执行三次 next 方法（因为 F 内部有两个 yield 语句），完成 F 内部所有代码的运行。这时，所有内部属性都绑定在 obj 对象上了，因此 obj 对象也就成了 F 的实例。 上面代码中，执行的是遍历器对象 f，但是生成的对象实例是 obj，有没有办法将这两个对象统一呢？ 一个办法就是将 obj 换成 F.prototype。 1234567891011121314function* F() &#123; this.a = 1 yield (this.b = 2) yield (this.c = 3)&#125;var f = F.call(F.prototype)f.next() // Object &#123;value: 2, done: false&#125;f.next() // Object &#123;value: 3, done: false&#125;f.next() // Object &#123;value: undefined, done: true&#125;f.a // 1f.b // 2f.c // 3 Generator 函数也不能跟 new 命令一起用，会报错。 1234567function* F() &#123; yield (this.x = 2) yield (this.y = 3)&#125;new F()// TypeError: F is not a constructor 上面代码中，new 命令跟函数 F 一起使用，结果报错，因为 F 不是构造函数。 将 F 改成构造函数，就可以对它执行 new 命令了。 12345678910111213141516171819function* gen() &#123; this.a = 1 yield (this.b = 2) yield (this.c = 3)&#125;function F() &#123; return gen.call(gen.prototype)&#125;var f = new F()f.next() // Object &#123;value: 2, done: false&#125;f.next() // Object &#123;value: 3, done: false&#125;f.next() // Object &#123;value: undefined, done: true&#125;f.a // 1f.b // 2f.c // 3 七、Generator 与状态机、Generator 与协程状态机 Generator 是实现状态机的最佳结构。 12345678910111213141516171819var ticking = true;var clock = function() &#123; // ES5实现 if (ticking) console.log('Tick!'); else console.log('Tock!'); ticking = !ticking;&#125; ----------------分割线----------------var clock = function*() &#123; // Generator实现 while (true) &#123; console.log('Tick!'); yield; console.log('Tock!'); yield; &#125;&#125;; 上面的 Generator 实现与 ES5 实现对比，可以看到少了用来保存状态的外部变量 ticking，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator 之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。 协程 协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。 1. 协程与子例程的差异 传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。 协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。 也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。 从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。 2. 协程与普通线程的差异 不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。 此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。 由于 ECMAScript 是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。 Generator 函数是 ECMAScript 6 对协程的实现，但属于不完全实现。Generator 函数被称为“半协程”（semi-coroutine），意思是只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。 如果将 Generator 函数当作协程，完全可以将多个需要互相协作的任务写成 Generator 函数，它们之间使用 yield 语句交换控制权。 应用Generator 可以暂停函数执行，返回任意表达式的值。这种特点使得 Generator 有多种应用场景。 （1）异步操作的同步化表达 Generator 函数的暂停执行的效果，意味着可以把异步操作写在 yield 语句里面，等到调用 next 方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在 yield 语句下面，反正要等到调用 next 方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数。 Ajax 是典型的异步操作，通过 Generator 函数部署 Ajax 操作，可以用同步的方式表达。 1234567891011121314function* main() &#123; var result = yield request('http://some.url') var resp = JSON.parse(result) console.log(resp.value)&#125;function request(url) &#123; makeAjaxCall(url, function(response) &#123; it.next(response) &#125;)&#125;var it = main()it.next() 上面代码的 main 函数，就是通过 Ajax 操作获取数据。可以看到，除了多了一个 yield，它几乎与同步操作的写法完全一样。注意，makeAjaxCall 函数中的 next 方法，必须加上 response 参数，因为 yield 语句构成的表达式，本身是没有值的，总是等于 undefined。 下面是另一个例子，通过 Generator 函数逐行读取文本文件。 12345678910function* numbers() &#123; let file = new FileReader('numbers.txt') try &#123; while (!file.eof) &#123; yield parseInt(file.readLine(), 10) &#125; &#125; finally &#123; file.close() &#125;&#125; 上面代码打开文本文件，使用 yield 语句可以手动逐行读取文件。 （2）控制流管理 回调函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354step1(function(value1) &#123; step2(value1, function(value2) &#123; step3(value2, function(value3) &#123; step4(value3, function(value4) &#123; // Do something with value4 &#125;) &#125;) &#125;)&#125;)// -------------↓Promise改写↓-------------Promise.resolve(step1) .then(step2) .then(step3) .then(step4) .then( function(value4) &#123; // Do something with value4 &#125;, function(error) &#123; // Handle any error from step1 through step4 &#125; ) .done()// -------------↓Generator函数改善代码运行流程↓-------------function* longRunningTask(value1) &#123; try &#123; var value2 = yield step1(value1) var value3 = yield step2(value2) var value4 = yield step3(value3) var value5 = yield step4(value4) // Do something with value4 &#125; catch (e) &#123; // Handle any error from step1 through step4 &#125;&#125;// 然后，使用一个函数，按次序自动执行所有步骤。scheduler(longRunningTask(initialValue))function scheduler(task) &#123; var taskObj = task.next(task.value) // 如果Generator函数未结束，就继续调用 if (!taskObj.done) &#123; task.value = taskObj.value scheduler(task) &#125;&#125;// 注意，上面这种做法，只适合同步操作，即所有的task都必须是同步的，不能有异步操作。// 因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。 （3）部署 Iterator 接口 利用 Generator 函数，可以在任意对象上部署 Iterator 接口。 → 可参考&lt;标题:四&gt;的例子 123456789101112131415function* iterEntries(obj) &#123; let keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; let key = keys[i] yield [key, obj[key]] &#125;&#125;let myObj = &#123; foo: 3, bar: 7 &#125;for (let [key, value] of iterEntries(myObj)) &#123; console.log(key, value)&#125;// foo 3// bar 7 上述代码中，myObj 是一个普通对象，通过 iterEntries 函数，就有了 Iterator 接口。也就是说，可以在任意对象上部署 next 方法。 下面是一个对数组部署 Iterator 接口的例子，尽管数组原生具有这个接口。 12345678910111213function* makeSimpleGenerator(array) &#123; var nextIndex = 0 while (nextIndex &lt; array.length) &#123; yield array[nextIndex++] &#125;&#125;var gen = makeSimpleGenerator(['yo', 'ya'])gen.next().value // 'yo'gen.next().value // 'ya'gen.next().done // true （4）作为数据结构 Generator 可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为 Generator 函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。 123456789101112131415161718192021function *doStuff() &#123; yield fs.readFile.bind(null, 'hello.txt'); yield fs.readFile.bind(null, 'world.txt'); yield fs.readFile.bind(null, 'and-such.txt');&#125;// 上面代码就是依次返回三个函数，但是由于使用了Generator函数，导致可以像处理数组那样，处理这三个返回的函数。for (task of doStuff()) &#123; // task是一个函数，可以像回调函数那样使用它&#125; -------------分割线-------------// 实际上，如果用ES5表达，完全可以用数组模拟Generator的这种用法。function doStuff() &#123; return [ fs.readFile.bind(null, 'hello.txt'), fs.readFile.bind(null, 'world.txt'), fs.readFile.bind(null, 'and-such.txt') ];&#125; 上面的函数，可以用一模一样的 for…of 循环处理！两相一比较，就不难看出 Generator 使得数据或者操作，具备了类似数组的接口。 Generator 函数 一、理解 Generator(生成器) 二、yield yield* 注意事项 三、next 方法的参数 四、配合使用 for…of 循环 五、Generator 函数返回的遍历器对象的方法 1. Generator.prototype.throw() 2. Generator.prototype.return() 六、Generator 函数的 this 七、Generator 与状态机、Generator 与协程 状态机 协程 应用]]></content>
      <categories>
        <category>ES6+</category>
      </categories>
      <tags>
        <tag>ECMAScript6+</tag>
        <tag>Generator</tag>
        <tag>状态机</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你需要学习的 Promise对象]]></title>
    <url>%2F2018%2F12%2F21%2FPromise%2F</url>
    <content type="text"><![CDATA[Promise 对象© Chirenmeng 一、Promise 的含义摘自：MDN —— Promise Promise 对象是一个代理对象（代理一个值），被代理的值在 Promise 对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的 promise 对象 一个 Promise 有以下几种状态: pending: 初始状态，既不是成功，也不是失败状态。 fulfilled: 意味着操作成功完成。 rejected: 意味着操作失败。 pending 状态的 Promise 对象可能触发 fulfilled 状态并传递一个值给相应的状态处理方法，也可能触发失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers ）就会被调用（then 方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当 Promise 状态为 fulfilled 时，调用 then 的 onfulfilled 方法，当 Promise 状态为 rejected 时，调用 then 的 onrejected 方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争）。 因为 Promise.prototype.then 和 Promise.prototype.catch 方法返回 promise 对象， 所以它们可以被链式调用。 二、基本用法简单的例子1234567891011121314151617181920let myFirstPromise = new Promise(function(resolve, reject) &#123; //当异步代码执行成功时，我们才会调用resolve(...), 当异步代码失败时就会调用reject(...) //在本例中，我们使用setTimeout(...)来模拟异步代码，实际编码时可能是XHR请求或是HTML5的一些API方法. console.log('Promise') setTimeout(() =&gt; &#123; resolve('Resolved.') //代码正常执行！ &#125;, 100)&#125;)myFirstPromise.then(function(successMessage) &#123; //successMessage的值是上面调用resolve(...)方法传入的值. console.log(successMessage)&#125;)console.log('Hi!')// 上述代码会依次打印// Promise// Hi!// Resolved. 传递到 then 中的函数被置入了一个微任务队列，而不是立即执行，这意味着它是在 JavaScript 事件队列的所有运行时结束了，事件队列被清空之后才开始执行: 123456789const wait = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms))wait().then(() =&gt; console.log(4))Promise.resolve() .then(() =&gt; console.log(2)) .then(() =&gt; console.log(3))console.log(1) // 1, 2, 3, 4 Catch 的后续链式操作1234567891011121314151617181920212223new Promise((resolve, reject) =&gt; &#123; console.log('Initial') resolve()&#125;) .then(() =&gt; &#123; throw new Error('Something failed') console.log('Do this') &#125;) .catch(() =&gt; &#123; console.log('Do that') &#125;) .then(() =&gt; &#123; console.log('Do this whatever happened before') &#125;)// 上述代码会依次打印// Initial// Do that// Do this whatever happened before// 注意，由于“Something failed”错误导致了拒绝操作，所以“Do this”文本没有被输出。 Promise.prototype.done()Promise 对象的回调链，不管以 then 方法或 catch 方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为 Promise 内部的错误不会冒泡到全局）。因此，我们可以提供一个 done 方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。 Promise.prototype.finally()finally 方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。它与 done 方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。 Promise.all()Promise.all()接受一个由 promise 任务组成的数组，可以同时处理多个 promise 任务，当所有的任务都执行完成时，Promise.all()返回 resolve，但当有一个失败(reject)，则返回失败的信息，即使其他 promise 执行成功，也会返回失败。 Promise.race()顾名思义，Promse.race()就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。 Promise.resolve()有时需要将现有对象转为 Promise 对象，Promise.resolve 方法就起到这个作用。 1234567var p = Promise.resolve('foo')// 等价于var p = new Promise(resolve =&gt; resolve('foo'))p.then(function(s) &#123; console.log(s) // foo&#125;) Promise.reject()Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为 rejected。 1234567var p = Promise.reject('出错了')// 等同于var p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function(s) &#123; console.log(s) // 出错了&#125;) Promise 对象 一、Promise 的含义 二、基本用法 简单的例子 Catch 的后续链式操作 Promise.prototype.done() Promise.prototype.finally() Promise.all() Promise.race() Promise.resolve() Promise.reject()]]></content>
      <categories>
        <category>ES6+</category>
      </categories>
      <tags>
        <tag>ECMAScript6+</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[词法作用域]]></title>
    <url>%2F2018%2F12%2F12%2F%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[JavaScript 词法作用域© Chirenmeng 一、词法作用域是什么？ 词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里决定的。 二、查找标识符标识符标识符（Identifier）就是一个名字，用来对变量、函数、属性、参数进行命名，或者用做某些循环语句中的跳转位置的标记。 作用域气泡的结构和互相之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标识符的位置。 遮蔽效应 作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。 内部的标识符”遮蔽”了外部的标识符。全局变量会自动成为全局对象（比如浏览器中 window 对象的属性），但非全局的变量如果被遮蔽了，是无论如何都无法被访问到的。 三、欺骗词法在运行时修改（欺骗）词法作用域。【欺骗词法作用域会导致性能下降】 eval(..)函数可以接受一个字符串参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。 相似的 setTimeout(..)、setInterval(..)的第一个参数可以是字符串，字符串内容可以被解释为一段动态生成的函数。 new Function(..)函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转为动态生成的函数 ( 前面的形参是这个新生成函数的形参 ) 在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。 123456function foo(str, a) &#123; eval(str) // 欺骗词法 console.log(a, b)&#125;var b = 2foo('var b = 3;', 1) // 1 , 3 with，JavaScript 中另一个难以掌握 ( 并且现在也不推荐使用 ) 的用来欺骗词法作用域的功能是 with 关键字。 with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。 with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。 1234567891011121314151617var obj = &#123; a: 1, b: 2, c: 3&#125;// 单调乏味的重复objobj.a = 2obj.b = 3obj.c = 4// 简单的快捷方式with (obj) &#123; a = 3 b = 3 c = 3&#125; 12345678910111213141516function foo(obj) &#123; with (obj) &#123; a = 2 &#125;&#125;var o1 = &#123; a: 3&#125;var o1 = &#123; b: 3&#125;foo(o1)console.log(o1.a) // 2foo(o2)console.log(o2.a) // undefindconsole.log(a) // 2 ——不好，a被泄漏到全局作用域上了! 注：eval(..)函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而 with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。 catch，除了 eval 与 with 之外，try-catch 语句中的 catch 子句同样可以修改执行环境的作用域链 当 try 代码块内发生错误，执行流立即跳转到 catch 子句 随后把异常对象推入一个可变对象并且放到作用域链最前面，这和 with 很像 一旦 catch 子句执行完毕，作用域链就会恢复原样 123456try &#123; throw 2&#125; catch (a) &#123; console.log(a) // 2&#125;console.log(a) //ReferenceError: a is not defined JavaScript 引擎会在编译阶段进行数项的性能优化，其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。 在运行时才对作用域进行出行，所以如果无法明确的知道会接收到什么代码，这些代码会如何对作用域进行修改，可能导致所有的优化都是无意义的，因此最简单的做法就是完全不做任何优化。（不要使用他们） 词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的(this 也是)。词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。 JavaScript 词法作用域 一、词法作用域是什么？ 二、查找标识符 标识符 遮蔽效应 三、欺骗词法]]></content>
      <categories>
        <category>你不知道的JavaScript</category>
      </categories>
      <tags>
        <tag>作用域</tag>
        <tag>词法作用域</tag>
        <tag>标识符</tag>
        <tag>遮蔽效应</tag>
        <tag>欺骗词法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[作用域]]></title>
    <url>%2F2018%2F12%2F12%2F%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[JavaScript 作用域© Chirenmeng 一、作用域是什么？编程语言设计了一套良好的规则来储存变量，并且之后可以方便地找到这些变量，这套规则被称为作用域。 （简单来说，作用域就是能让你储存变量当中的值，并且之后能够进行访问和修改） 二、编译流程 分词/词法分析 （完成分词这个目的，需要通过词法分析这个手段） 这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元。 解析/语法分析 这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树（抽象语法树–AST）。 代码生成 将 AST 转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息息相关。 注：JavaScript 引擎编译流程更为复杂，比如，在语法分析和代码生成阶段有特定的步骤对性能进行优化，包括对冗余元素进行优化。并且对于 JavaScript 而言，大部分情况下编译发生在代码执行前的几微秒内。JavaScript 引擎用尽了各种办法（比如即时编译–JIT）来保证性能最佳。 三、各自的职责 引擎：负责整个编译和执行过程 编译器：负责语法分析及代码生成 作用域：负责收集并维护所有声明的变量，组成的一系列查询，并实施一套严格的规则，确定当前执行的代码对折现变量的访问权限。 四、变量的赋值操作 变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。 LHS 和 RHS，当引擎执行编译器给的代码（赋值操作）时，会通过查找这个变量来判断这个变量是否已经声明，这个过程需要作用域的协助，而查找的方式分为两种：LHS（”赋值操作的目标是谁”）和 RHS（”谁是赋值操作的源头”）。 LHS：赋值操作的左侧，试图查找到变量的容器本身，从而可以对其赋值，即找到复制操作的目标。 RHS：另外一种查找，可以简单理解为复制操作的右侧，其查找目标为取到目标的源值，即找到这个变量具体的值而非容器。 1234567891011function foo(a) &#123;var b = a;return a + b;&#125;var c = foo( 2 );1. 找出所有的 LHS 查询（这里有 3 处！）c = ..; 、 a = 2 （隐式变量分配）、 b = ..2. 找出所有的 RHS 查询（这里有 4 处！）foo(2.. 、 = a; 、 a .. 、 .. b JavaScript 作用域 一、作用域是什么？ 二、编译流程 三、各自的职责 四、变量的赋值操作]]></content>
      <categories>
        <category>你不知道的JavaScript</category>
      </categories>
      <tags>
        <tag>作用域</tag>
        <tag>编译流程</tag>
        <tag>抽象语法树</tag>
        <tag>引擎</tag>
        <tag>编译器</tag>
        <tag>赋值</tag>
      </tags>
  </entry>
</search>
